
image:     formato del fichero elf32-lm32

Secciones:
Ind Nombre        Tamaño    VMA       LMA       Desp fich Alin
  0 .text         000010a4  00000000  00000000  00000054  2**2
                  CONTENTS, ALLOC, LOAD, CODE
  1 .rodata       00000110  000010a4  000010a4  000010f8  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  2 .data         000000b0  000011b4  000011b4  00001208  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  3 .bss          00000090  00001264  00001264  000012b8  2**2
                  ALLOC
  4 .debug_abbrev 000003b3  00000000  00000000  000012b8  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_info   00001379  00000000  00000000  0000166b  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_line   00000cf7  00000000  00000000  000029e4  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_frame  00000210  00000000  00000000  000036dc  2**2
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_loc    000007cc  00000000  00000000  000038ec  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_pubnames 0000036a  00000000  00000000  000040b8  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_pubtypes 000000b2  00000000  00000000  00004422  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_aranges 00000040  00000000  00000000  000044d4  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_str    000006c3  00000000  00000000  00004514  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .comment      00000011  00000000  00000000  00004bd7  2**0
                  CONTENTS, READONLY
 14 .debug_ranges 00000018  00000000  00000000  00004be8  2**0
                  CONTENTS, READONLY, DEBUGGING

Desensamblado de la sección .text:

00000000 <_ftext>:
       0:	98 00 00 00 	xor r0,r0,r0
       4:	d0 00 00 00 	wcsr IE,r0
       8:	78 01 00 00 	mvhi r1,0x0
       c:	38 21 00 00 	ori r1,r1,0x0
      10:	d0 e1 00 00 	wcsr EBA,r1
      14:	f8 00 00 3b 	calli 100 <_crt0>
      18:	34 00 00 00 	nop
      1c:	34 00 00 00 	nop

00000020 <_breakpoint_handler>:
      20:	34 00 00 00 	nop
      24:	34 00 00 00 	nop
      28:	34 00 00 00 	nop
      2c:	34 00 00 00 	nop
      30:	34 00 00 00 	nop
      34:	34 00 00 00 	nop
      38:	34 00 00 00 	nop
      3c:	34 00 00 00 	nop

00000040 <_ibuserror_handler>:
      40:	34 00 00 00 	nop
      44:	34 00 00 00 	nop
      48:	34 00 00 00 	nop
      4c:	34 00 00 00 	nop
      50:	34 00 00 00 	nop
      54:	34 00 00 00 	nop
      58:	34 00 00 00 	nop
      5c:	34 00 00 00 	nop

00000060 <_watchpoint_handler>:
      60:	34 00 00 00 	nop
      64:	34 00 00 00 	nop
      68:	34 00 00 00 	nop
      6c:	34 00 00 00 	nop
      70:	34 00 00 00 	nop
      74:	34 00 00 00 	nop
      78:	34 00 00 00 	nop
      7c:	34 00 00 00 	nop

00000080 <_dbuserror_handler>:
      80:	34 00 00 00 	nop
      84:	34 00 00 00 	nop
      88:	34 00 00 00 	nop
      8c:	34 00 00 00 	nop
      90:	34 00 00 00 	nop
      94:	34 00 00 00 	nop
      98:	34 00 00 00 	nop
      9c:	34 00 00 00 	nop

000000a0 <_divzero_handler>:
      a0:	34 00 00 00 	nop
      a4:	34 00 00 00 	nop
      a8:	34 00 00 00 	nop
      ac:	34 00 00 00 	nop
      b0:	34 00 00 00 	nop
      b4:	34 00 00 00 	nop
      b8:	34 00 00 00 	nop
      bc:	34 00 00 00 	nop

000000c0 <_interrupt_handler>:
      c0:	5b 9d 00 00 	sw (sp+0),ra
      c4:	f8 00 00 2b 	calli 170 <_save_all>
      c8:	90 40 08 00 	rcsr r1,IP
      cc:	f8 00 03 04 	calli cdc <irq_handler>
      d0:	78 01 ff ff 	mvhi r1,0xffff
      d4:	38 21 ff ff 	ori r1,r1,0xffff
      d8:	d0 41 00 00 	wcsr IP,r1
      dc:	e0 00 00 38 	bi 1bc <_restore_all_and_eret>

000000e0 <_scall_handler>:
      e0:	34 00 00 00 	nop
      e4:	34 00 00 00 	nop
      e8:	34 00 00 00 	nop
      ec:	34 00 00 00 	nop
      f0:	34 00 00 00 	nop
      f4:	34 00 00 00 	nop
      f8:	34 00 00 00 	nop
      fc:	34 00 00 00 	nop

00000100 <_crt0>:
     100:	78 1c 00 00 	mvhi sp,0x0
     104:	3b 9c 1f fc 	ori sp,sp,0x1ffc
     108:	78 1a 00 00 	mvhi gp,0x0
     10c:	3b 5a 12 70 	ori gp,gp,0x1270
     110:	78 01 00 00 	mvhi r1,0x0
     114:	38 21 12 64 	ori r1,r1,0x1264
     118:	78 03 00 00 	mvhi r3,0x0
     11c:	38 63 12 f4 	ori r3,r3,0x12f4

00000120 <.clearBSS>:
     120:	44 23 00 04 	be r1,r3,130 <.callMain>
     124:	58 20 00 00 	sw (r1+0),r0
     128:	34 21 00 04 	addi r1,r1,4
     12c:	e3 ff ff fd 	bi 120 <.clearBSS>

00000130 <.callMain>:
     130:	34 01 00 00 	mvi r1,0
     134:	34 02 00 00 	mvi r2,0
     138:	34 03 00 00 	mvi r3,0
     13c:	f8 00 02 16 	calli 994 <main>

00000140 <irq_enable>:
     140:	34 01 00 01 	mvi r1,1
     144:	d0 01 00 00 	wcsr IE,r1
     148:	c3 a0 00 00 	ret

0000014c <irq_disable>:
     14c:	34 01 00 00 	mvi r1,0
     150:	d0 01 00 00 	wcsr IE,r1
     154:	c3 a0 00 00 	ret

00000158 <irq_set_mask>:
     158:	d0 21 00 00 	wcsr IM,r1
     15c:	c3 a0 00 00 	ret

00000160 <irq_get_mask>:
     160:	90 20 08 00 	rcsr r1,IM
     164:	c3 a0 00 00 	ret

00000168 <jump>:
     168:	c0 20 00 00 	b r1

0000016c <halt>:
     16c:	e0 00 00 00 	bi 16c <halt>

00000170 <_save_all>:
     170:	37 9c ff 80 	addi sp,sp,-128
     174:	5b 81 00 04 	sw (sp+4),r1
     178:	5b 82 00 08 	sw (sp+8),r2
     17c:	5b 83 00 0c 	sw (sp+12),r3
     180:	5b 84 00 10 	sw (sp+16),r4
     184:	5b 85 00 14 	sw (sp+20),r5
     188:	5b 86 00 18 	sw (sp+24),r6
     18c:	5b 87 00 1c 	sw (sp+28),r7
     190:	5b 88 00 20 	sw (sp+32),r8
     194:	5b 89 00 24 	sw (sp+36),r9
     198:	5b 8a 00 28 	sw (sp+40),r10
     19c:	5b 9e 00 78 	sw (sp+120),ea
     1a0:	5b 9f 00 7c 	sw (sp+124),ba
     1a4:	2b 81 00 80 	lw r1,(sp+128)
     1a8:	5b 81 00 74 	sw (sp+116),r1
     1ac:	bb 80 08 00 	mv r1,sp
     1b0:	34 21 00 80 	addi r1,r1,128
     1b4:	5b 81 00 70 	sw (sp+112),r1
     1b8:	c3 a0 00 00 	ret

000001bc <_restore_all_and_eret>:
     1bc:	2b 81 00 04 	lw r1,(sp+4)
     1c0:	2b 82 00 08 	lw r2,(sp+8)
     1c4:	2b 83 00 0c 	lw r3,(sp+12)
     1c8:	2b 84 00 10 	lw r4,(sp+16)
     1cc:	2b 85 00 14 	lw r5,(sp+20)
     1d0:	2b 86 00 18 	lw r6,(sp+24)
     1d4:	2b 87 00 1c 	lw r7,(sp+28)
     1d8:	2b 88 00 20 	lw r8,(sp+32)
     1dc:	2b 89 00 24 	lw r9,(sp+36)
     1e0:	2b 8a 00 28 	lw r10,(sp+40)
     1e4:	2b 9d 00 74 	lw ra,(sp+116)
     1e8:	2b 9e 00 78 	lw ea,(sp+120)
     1ec:	2b 9f 00 7c 	lw ba,(sp+124)
     1f0:	2b 9c 00 70 	lw sp,(sp+112)
     1f4:	c3 c0 00 00 	eret

000001f8 <get_sp>:
     1f8:	bb 80 08 00 	mv r1,sp
     1fc:	c3 a0 00 00 	ret

00000200 <get_gp>:
     200:	bb 40 08 00 	mv r1,gp
     204:	c3 a0 00 00 	ret

00000208 <writeintB>:
 */

#include "soc-hw.h"

inline void writeintB(volatile uint32_t val)
{
     208:	37 9c ff e8 	addi sp,sp,-24
     20c:	5b 8b 00 10 	sw (sp+16),r11
     210:	5b 8c 00 0c 	sw (sp+12),r12
     214:	5b 8d 00 08 	sw (sp+8),r13
     218:	5b 9d 00 04 	sw (sp+4),ra
     21c:	34 0b 00 08 	mvi r11,8
     220:	5b 81 00 14 	sw (sp+20),r1
	uint32_t i, j;
	volatile uint32_t digit;

	for (i=0; i<8; i++) {
		digit = (val & 0xF0000000);
     224:	78 0d f0 00 	mvhi r13,0xf000
		for(j=0; j<28; j++){
			digit >>= 28;
		}
		if (digit >= 0xA) {
     228:	34 0c 00 09 	mvi r12,9
{
	uint32_t i, j;
	volatile uint32_t digit;

	for (i=0; i<8; i++) {
		digit = (val & 0xF0000000);
     22c:	2b 82 00 14 	lw r2,(sp+20)
     230:	34 01 00 1c 	mvi r1,28
     234:	a0 4d 10 00 	and r2,r2,r13
     238:	5b 82 00 18 	sw (sp+24),r2
		for(j=0; j<28; j++){
			digit >>= 28;
     23c:	2b 82 00 18 	lw r2,(sp+24)
     240:	34 21 ff ff 	addi r1,r1,-1
     244:	00 42 00 1c 	srui r2,r2,28
     248:	5b 82 00 18 	sw (sp+24),r2
	uint32_t i, j;
	volatile uint32_t digit;

	for (i=0; i<8; i++) {
		digit = (val & 0xF0000000);
		for(j=0; j<28; j++){
     24c:	5c 20 ff fc 	bne r1,r0,23c <writeintB+0x34>
			digit >>= 28;
		}
		if (digit >= 0xA) {
     250:	2b 81 00 18 	lw r1,(sp+24)
     254:	51 81 00 0d 	bgeu r12,r1,288 <writeintB+0x80>
			uart_putchar('A'+digit-10);  //uart_putchar('Y');
     258:	2b 81 00 18 	lw r1,(sp+24)
     25c:	34 21 00 37 	addi r1,r1,55
     260:	20 21 00 ff 	andi r1,r1,0xff
     264:	f8 00 03 02 	calli e6c <uart_putchar>
			}
		else{
			uart_putchar('0'+digit);  //uart_putchar('N');
		for(j=0; j<4; j++){
     268:	35 6b ff ff 	addi r11,r11,-1
inline void writeintB(volatile uint32_t val)
{
	uint32_t i, j;
	volatile uint32_t digit;

	for (i=0; i<8; i++) {
     26c:	5d 60 ff f0 	bne r11,r0,22c <writeintB+0x24>
			val <<= 4;
		}
		
		}
	}
}
     270:	2b 9d 00 04 	lw ra,(sp+4)
     274:	2b 8b 00 10 	lw r11,(sp+16)
     278:	2b 8c 00 0c 	lw r12,(sp+12)
     27c:	2b 8d 00 08 	lw r13,(sp+8)
     280:	37 9c 00 18 	addi sp,sp,24
     284:	c3 a0 00 00 	ret
		}
		if (digit >= 0xA) {
			uart_putchar('A'+digit-10);  //uart_putchar('Y');
			}
		else{
			uart_putchar('0'+digit);  //uart_putchar('N');
     288:	2b 81 00 18 	lw r1,(sp+24)
     28c:	34 21 00 30 	addi r1,r1,48
     290:	20 21 00 ff 	andi r1,r1,0xff
     294:	f8 00 02 f6 	calli e6c <uart_putchar>
     298:	34 01 00 04 	mvi r1,4
		for(j=0; j<4; j++){
			val <<= 4;
     29c:	2b 82 00 14 	lw r2,(sp+20)
     2a0:	34 21 ff ff 	addi r1,r1,-1
     2a4:	3c 42 00 04 	sli r2,r2,4
     2a8:	5b 82 00 14 	sw (sp+20),r2
		if (digit >= 0xA) {
			uart_putchar('A'+digit-10);  //uart_putchar('Y');
			}
		else{
			uart_putchar('0'+digit);  //uart_putchar('N');
		for(j=0; j<4; j++){
     2ac:	5c 20 ff fc 	bne r1,r0,29c <writeintB+0x94>
     2b0:	e3 ff ff ee 	bi 268 <writeintB+0x60>

000002b4 <writeintC>:
		}
	}
}

inline void writeintC(uint32_t val)
{
     2b4:	37 9c ff f0 	addi sp,sp,-16
     2b8:	5b 8b 00 10 	sw (sp+16),r11
     2bc:	5b 8c 00 0c 	sw (sp+12),r12
     2c0:	5b 8d 00 08 	sw (sp+8),r13
     2c4:	5b 9d 00 04 	sw (sp+4),ra
     2c8:	34 0b 00 08 	mvi r11,8
     2cc:	b8 20 60 00 	mv r12,r1
	uint32_t i, digit;

	for (i=0; i<8; i++) {
		digit = (val & 0xF0000000) >> 28;
		if (digit >= 0xA) 
     2d0:	34 0d 00 09 	mvi r13,9
     2d4:	e0 00 00 02 	bi 2dc <writeintC+0x28>
			uart_putchar('A'+digit-10);
		else
			uart_putchar('0'+digit);
		val <<= 4;
     2d8:	3d 8c 00 04 	sli r12,r12,4
inline void writeintC(uint32_t val)
{
	uint32_t i, digit;

	for (i=0; i<8; i++) {
		digit = (val & 0xF0000000) >> 28;
     2dc:	01 82 00 1c 	srui r2,r12,28
		if (digit >= 0xA) 
			uart_putchar('A'+digit-10);
     2e0:	34 41 00 37 	addi r1,r2,55
{
	uint32_t i, digit;

	for (i=0; i<8; i++) {
		digit = (val & 0xF0000000) >> 28;
		if (digit >= 0xA) 
     2e4:	51 a2 00 0a 	bgeu r13,r2,30c <writeintC+0x58>
			uart_putchar('A'+digit-10);
		else
			uart_putchar('0'+digit);
     2e8:	35 6b ff ff 	addi r11,r11,-1
     2ec:	f8 00 02 e0 	calli e6c <uart_putchar>

inline void writeintC(uint32_t val)
{
	uint32_t i, digit;

	for (i=0; i<8; i++) {
     2f0:	5d 60 ff fa 	bne r11,r0,2d8 <writeintC+0x24>
			uart_putchar('A'+digit-10);
		else
			uart_putchar('0'+digit);
		val <<= 4;
	}
}
     2f4:	2b 9d 00 04 	lw ra,(sp+4)
     2f8:	2b 8b 00 10 	lw r11,(sp+16)
     2fc:	2b 8c 00 0c 	lw r12,(sp+12)
     300:	2b 8d 00 08 	lw r13,(sp+8)
     304:	37 9c 00 10 	addi sp,sp,16
     308:	c3 a0 00 00 	ret
	for (i=0; i<8; i++) {
		digit = (val & 0xF0000000) >> 28;
		if (digit >= 0xA) 
			uart_putchar('A'+digit-10);
		else
			uart_putchar('0'+digit);
     30c:	34 41 00 30 	addi r1,r2,48
     310:	e3 ff ff f6 	bi 2e8 <writeintC+0x34>

00000314 <read_uint32>:
		val <<= 4;
	}
}

uint32_t read_uint32()
{
     314:	37 9c ff f4 	addi sp,sp,-12
     318:	5b 8b 00 0c 	sw (sp+12),r11
     31c:	5b 8c 00 08 	sw (sp+8),r12
     320:	5b 9d 00 04 	sw (sp+4),ra
     324:	34 0b 00 04 	mvi r11,4
	uint32_t val = 0, i;
     328:	34 01 00 00 	mvi r1,0

    for (i = 0; i < 4; i++) {
        val <<= 8;
     32c:	3c 2c 00 08 	sli r12,r1,8
        val += (uint8_t)uart_getchar();
     330:	35 6b ff ff 	addi r11,r11,-1
     334:	f8 00 02 c5 	calli e48 <uart_getchar>
     338:	b4 2c 08 00 	add r1,r1,r12

uint32_t read_uint32()
{
	uint32_t val = 0, i;

    for (i = 0; i < 4; i++) {
     33c:	5d 60 ff fc 	bne r11,r0,32c <read_uint32+0x18>
        val <<= 8;
        val += (uint8_t)uart_getchar();
    }

    return val;
}
     340:	2b 9d 00 04 	lw ra,(sp+4)
     344:	2b 8b 00 0c 	lw r11,(sp+12)
     348:	2b 8c 00 08 	lw r12,(sp+8)
     34c:	37 9c 00 0c 	addi sp,sp,12
     350:	c3 a0 00 00 	ret

00000354 <writeint>:

void writeint(uint32_t entero) //Esta función permite escribir en la UART, de manera hexadecimal, un numero entero
{
     354:	37 9c ff e8 	addi sp,sp,-24
     358:	5b 8b 00 10 	sw (sp+16),r11
     35c:	5b 8c 00 0c 	sw (sp+12),r12
     360:	5b 8d 00 08 	sw (sp+8),r13
     364:	5b 9d 00 04 	sw (sp+4),ra
		val = *p1;
		for(j=0; j<4; j++)
		{
			val = val>>4;
		}
		if (val >= 0xA) 
     368:	34 0c 00 09 	mvi r12,9

    return val;
}

void writeint(uint32_t entero) //Esta función permite escribir en la UART, de manera hexadecimal, un numero entero
{
     36c:	5b 81 00 14 	sw (sp+20),r1
	//entero = (entero & 0x0000000F);
	volatile uint8_t *p1 = &entero;
     370:	37 8b 00 14 	addi r11,sp,20
    }

    return val;
}

void writeint(uint32_t entero) //Esta función permite escribir en la UART, de manera hexadecimal, un numero entero
     374:	37 8d 00 17 	addi r13,sp,23
	uint32_t i,j;
	
	volatile uint8_t val;
	
	for(i = 0; i<4 ; i++){
		val = *p1;
     378:	41 62 00 00 	lbu r2,(r11+0)
     37c:	34 01 00 04 	mvi r1,4
     380:	20 42 00 ff 	andi r2,r2,0xff
     384:	33 82 00 1b 	sb (sp+27),r2
		for(j=0; j<4; j++)
		{
			val = val>>4;
     388:	43 82 00 1b 	lbu r2,(sp+27)
     38c:	34 21 ff ff 	addi r1,r1,-1
     390:	20 42 00 ff 	andi r2,r2,0xff
     394:	00 42 00 04 	srui r2,r2,4
     398:	33 82 00 1b 	sb (sp+27),r2
	
	volatile uint8_t val;
	
	for(i = 0; i<4 ; i++){
		val = *p1;
		for(j=0; j<4; j++)
     39c:	5c 20 ff fb 	bne r1,r0,388 <writeint+0x34>
		{
			val = val>>4;
		}
		if (val >= 0xA) 
     3a0:	43 81 00 1b 	lbu r1,(sp+27)
     3a4:	20 21 00 ff 	andi r1,r1,0xff
     3a8:	51 81 00 20 	bgeu r12,r1,428 <writeint+0xd4>
			uart_putchar('A'+ (val) -10);
     3ac:	43 81 00 1b 	lbu r1,(sp+27)
     3b0:	34 21 00 37 	addi r1,r1,55
     3b4:	20 21 00 ff 	andi r1,r1,0xff
     3b8:	f8 00 02 ad 	calli e6c <uart_putchar>
		else
			uart_putchar('0'+ (val));
	
		val = *p1;
     3bc:	41 61 00 00 	lbu r1,(r11+0)
     3c0:	20 21 00 ff 	andi r1,r1,0xff
     3c4:	33 81 00 1b 	sb (sp+27),r1
		val = val & 0x0F;
     3c8:	43 81 00 1b 	lbu r1,(sp+27)
     3cc:	20 21 00 0f 	andi r1,r1,0xf
     3d0:	33 81 00 1b 	sb (sp+27),r1
		if (val >= 0xA)
     3d4:	43 81 00 1b 	lbu r1,(sp+27)
     3d8:	20 21 00 ff 	andi r1,r1,0xff
     3dc:	51 81 00 08 	bgeu r12,r1,3fc <writeint+0xa8>
				uart_putchar('A'+ (val) -10);
     3e0:	43 81 00 1b 	lbu r1,(sp+27)
     3e4:	34 21 00 37 	addi r1,r1,55
     3e8:	20 21 00 ff 	andi r1,r1,0xff
     3ec:	f8 00 02 a0 	calli e6c <uart_putchar>
	volatile uint8_t *p1 = &entero;
	uint32_t i,j;
	
	volatile uint8_t val;
	
	for(i = 0; i<4 ; i++){
     3f0:	45 6d 00 08 	be r11,r13,410 <writeint+0xbc>
		val = val & 0x0F;
		if (val >= 0xA)
				uart_putchar('A'+ (val) -10);
			else
				uart_putchar('0'+ (val));
		p1++;
     3f4:	35 6b 00 01 	addi r11,r11,1
     3f8:	e3 ff ff e0 	bi 378 <writeint+0x24>
		val = *p1;
		val = val & 0x0F;
		if (val >= 0xA)
				uart_putchar('A'+ (val) -10);
			else
				uart_putchar('0'+ (val));
     3fc:	43 81 00 1b 	lbu r1,(sp+27)
     400:	34 21 00 30 	addi r1,r1,48
     404:	20 21 00 ff 	andi r1,r1,0xff
     408:	f8 00 02 99 	calli e6c <uart_putchar>
	volatile uint8_t *p1 = &entero;
	uint32_t i,j;
	
	volatile uint8_t val;
	
	for(i = 0; i<4 ; i++){
     40c:	5d 6d ff fa 	bne r11,r13,3f4 <writeint+0xa0>
				uart_putchar('A'+ (val) -10);
			else
				uart_putchar('0'+ (val));
		p1++;
	}
}
     410:	2b 9d 00 04 	lw ra,(sp+4)
     414:	2b 8b 00 10 	lw r11,(sp+16)
     418:	2b 8c 00 0c 	lw r12,(sp+12)
     41c:	2b 8d 00 08 	lw r13,(sp+8)
     420:	37 9c 00 18 	addi sp,sp,24
     424:	c3 a0 00 00 	ret
			val = val>>4;
		}
		if (val >= 0xA) 
			uart_putchar('A'+ (val) -10);
		else
			uart_putchar('0'+ (val));
     428:	43 81 00 1b 	lbu r1,(sp+27)
     42c:	34 21 00 30 	addi r1,r1,48
     430:	20 21 00 ff 	andi r1,r1,0xff
     434:	f8 00 02 8e 	calli e6c <uart_putchar>
     438:	e3 ff ff e1 	bi 3bc <writeint+0x68>

0000043c <writeintXX>:
	}
}

//Esta función permite escribir en la UART, de manera hexadecimal, los primeros 8 bits de un numero entero
void writeintXX(uint32_t entero)
{
     43c:	37 9c ff f4 	addi sp,sp,-12
     440:	5b 9d 00 04 	sw (sp+4),ra
     444:	5b 81 00 08 	sw (sp+8),r1
	p1 = p1 + 3;
	uint32_t j;
	
	volatile uint8_t val;
	
	val = *p1;
     448:	43 82 00 0b 	lbu r2,(sp+11)
     44c:	34 01 00 04 	mvi r1,4
     450:	20 42 00 ff 	andi r2,r2,0xff
     454:	33 82 00 0f 	sb (sp+15),r2
	for(j=0; j<4; j++)
	{
		val = val>>4;
     458:	43 82 00 0f 	lbu r2,(sp+15)
     45c:	34 21 ff ff 	addi r1,r1,-1
     460:	20 42 00 ff 	andi r2,r2,0xff
     464:	00 42 00 04 	srui r2,r2,4
     468:	33 82 00 0f 	sb (sp+15),r2
	uint32_t j;
	
	volatile uint8_t val;
	
	val = *p1;
	for(j=0; j<4; j++)
     46c:	5c 20 ff fb 	bne r1,r0,458 <writeintXX+0x1c>
	{
		val = val>>4;
	}
	if (val >= 0xA) 
     470:	43 81 00 0f 	lbu r1,(sp+15)
     474:	34 02 00 09 	mvi r2,9
     478:	20 21 00 ff 	andi r1,r1,0xff
     47c:	50 41 00 1d 	bgeu r2,r1,4f0 <writeintXX+0xb4>
		uart_putchar('A'+ (val) -10);
     480:	43 81 00 0f 	lbu r1,(sp+15)
     484:	34 21 00 37 	addi r1,r1,55
     488:	20 21 00 ff 	andi r1,r1,0xff
     48c:	f8 00 02 78 	calli e6c <uart_putchar>
	else
		uart_putchar('0'+ (val));

	val = *p1;
     490:	43 81 00 0b 	lbu r1,(sp+11)
	val = val & 0x0F;
	if (val >= 0xA)
     494:	34 02 00 09 	mvi r2,9
	if (val >= 0xA) 
		uart_putchar('A'+ (val) -10);
	else
		uart_putchar('0'+ (val));

	val = *p1;
     498:	20 21 00 ff 	andi r1,r1,0xff
     49c:	33 81 00 0f 	sb (sp+15),r1
	val = val & 0x0F;
     4a0:	43 81 00 0f 	lbu r1,(sp+15)
     4a4:	20 21 00 0f 	andi r1,r1,0xf
     4a8:	33 81 00 0f 	sb (sp+15),r1
	if (val >= 0xA)
     4ac:	43 81 00 0f 	lbu r1,(sp+15)
     4b0:	20 21 00 ff 	andi r1,r1,0xff
     4b4:	50 41 00 08 	bgeu r2,r1,4d4 <writeintXX+0x98>
			uart_putchar('A'+ (val) -10);
     4b8:	43 81 00 0f 	lbu r1,(sp+15)
     4bc:	34 21 00 37 	addi r1,r1,55
     4c0:	20 21 00 ff 	andi r1,r1,0xff
     4c4:	f8 00 02 6a 	calli e6c <uart_putchar>
		else
			uart_putchar('0'+ (val));
}
     4c8:	2b 9d 00 04 	lw ra,(sp+4)
     4cc:	37 9c 00 0c 	addi sp,sp,12
     4d0:	c3 a0 00 00 	ret
	val = *p1;
	val = val & 0x0F;
	if (val >= 0xA)
			uart_putchar('A'+ (val) -10);
		else
			uart_putchar('0'+ (val));
     4d4:	43 81 00 0f 	lbu r1,(sp+15)
     4d8:	34 21 00 30 	addi r1,r1,48
     4dc:	20 21 00 ff 	andi r1,r1,0xff
     4e0:	f8 00 02 63 	calli e6c <uart_putchar>
}
     4e4:	2b 9d 00 04 	lw ra,(sp+4)
     4e8:	37 9c 00 0c 	addi sp,sp,12
     4ec:	c3 a0 00 00 	ret
		val = val>>4;
	}
	if (val >= 0xA) 
		uart_putchar('A'+ (val) -10);
	else
		uart_putchar('0'+ (val));
     4f0:	43 81 00 0f 	lbu r1,(sp+15)
     4f4:	34 21 00 30 	addi r1,r1,48
     4f8:	20 21 00 ff 	andi r1,r1,0xff
     4fc:	f8 00 02 5c 	calli e6c <uart_putchar>
     500:	e3 ff ff e4 	bi 490 <writeintXX+0x54>

00000504 <Set_Bit>:
	}
}*/

void Set_Bit(  int reg, ///< The register to update. One of the PCD_Register enums.
               int mask ///< The bits to set.
            ) { 
     504:	37 9c ff f0 	addi sp,sp,-16
     508:	5b 8b 00 10 	sw (sp+16),r11
     50c:	5b 8c 00 0c 	sw (sp+12),r12
     510:	5b 8d 00 08 	sw (sp+8),r13
     514:	5b 9d 00 04 	sw (sp+4),ra
     518:	b8 40 58 00 	mv r11,r2
     51c:	b8 20 68 00 	mv r13,r1
  int tmp;
  tmp = readReg(reg);
     520:	f8 00 02 73 	calli eec <readReg>
     524:	b8 20 60 00 	mv r12,r1
  writeintXX(tmp);
     528:	fb ff ff c5 	calli 43c <writeintXX>
  writeReg(reg, tmp | mask);     // set bit mask
     52c:	b9 a0 08 00 	mv r1,r13
     530:	b9 8b 10 00 	or r2,r12,r11
     534:	f8 00 02 64 	calli ec4 <writeReg>
} // End PCD_Set_BitMask()
     538:	2b 9d 00 04 	lw ra,(sp+4)
     53c:	2b 8b 00 10 	lw r11,(sp+16)
     540:	2b 8c 00 0c 	lw r12,(sp+12)
     544:	2b 8d 00 08 	lw r13,(sp+8)
     548:	37 9c 00 10 	addi sp,sp,16
     54c:	c3 a0 00 00 	ret

00000550 <Clear_Bit>:

void Clear_Bit( int reg, ///< The register to update. One of the PCD_Register enums.
                int mask ///< The bits to clear.
                    ) {
     550:	37 9c ff f0 	addi sp,sp,-16
     554:	5b 8b 00 10 	sw (sp+16),r11
     558:	5b 8c 00 0c 	sw (sp+12),r12
     55c:	5b 8d 00 08 	sw (sp+8),r13
     560:	5b 9d 00 04 	sw (sp+4),ra
     564:	b8 40 68 00 	mv r13,r2
     568:	b8 20 60 00 	mv r12,r1
  int tmp;
  tmp = readReg(reg);
     56c:	f8 00 02 60 	calli eec <readReg>
     570:	b8 20 58 00 	mv r11,r1
  writeintXX(tmp);
     574:	fb ff ff b2 	calli 43c <writeintXX>
  writeReg(reg, tmp & (~mask));    // clear bit mask
     578:	a5 a0 10 00 	not r2,r13
     57c:	b9 80 08 00 	mv r1,r12
     580:	a1 62 10 00 	and r2,r11,r2
     584:	f8 00 02 50 	calli ec4 <writeReg>
} // End PCD_Clear_BitMask()
     588:	2b 9d 00 04 	lw ra,(sp+4)
     58c:	2b 8b 00 10 	lw r11,(sp+16)
     590:	2b 8c 00 0c 	lw r12,(sp+12)
     594:	2b 8d 00 08 	lw r13,(sp+8)
     598:	37 9c 00 10 	addi sp,sp,16
     59c:	c3 a0 00 00 	ret

000005a0 <newLine>:

void newLine() //Realiza un salto de línea y retorno de carro en el minicom
{
     5a0:	37 9c ff fc 	addi sp,sp,-4
     5a4:	5b 9d 00 04 	sw (sp+4),ra
	uart_putchar(0xA); //salto
     5a8:	34 01 00 0a 	mvi r1,10
     5ac:	f8 00 02 30 	calli e6c <uart_putchar>
	uart_putchar(0xD); //retorno de carro
     5b0:	34 01 00 0d 	mvi r1,13
     5b4:	f8 00 02 2e 	calli e6c <uart_putchar>
}
     5b8:	2b 9d 00 04 	lw ra,(sp+4)
     5bc:	37 9c 00 04 	addi sp,sp,4
     5c0:	c3 a0 00 00 	ret

000005c4 <initRFID>:

void initRFID()
{
     5c4:	37 9c ff fc 	addi sp,sp,-4
     5c8:	5b 9d 00 04 	sw (sp+4),ra
	//INIT

	//RESET
	uart_putstr("Toca hacer soft_reset");
     5cc:	78 01 00 00 	mvhi r1,0x0
     5d0:	38 21 10 a4 	ori r1,r1,0x10a4
     5d4:	f8 00 02 2f 	calli e90 <uart_putstr>
	writeReg(CommandReg, PCD_RESETPHASE);
     5d8:	34 01 00 02 	mvi r1,2
     5dc:	34 02 00 0f 	mvi r2,15
     5e0:	f8 00 02 39 	calli ec4 <writeReg>
	//FIN_RESET

	writeReg( TModeReg, 0x8D );      //Tauto=1; f(Timer) = 6.78MHz/TPreScaler
     5e4:	34 01 00 54 	mvi r1,84
     5e8:	34 02 00 8d 	mvi r2,141
     5ec:	f8 00 02 36 	calli ec4 <writeReg>
	writeReg( TPrescalerReg, 0x3E ); //TModeReg[3..0] + TPrescalerReg
     5f0:	34 01 00 56 	mvi r1,86
     5f4:	34 02 00 3e 	mvi r2,62
     5f8:	f8 00 02 33 	calli ec4 <writeReg>
	writeReg( TReloadRegL, 0x30 );           
     5fc:	34 01 00 5a 	mvi r1,90
     600:	34 02 00 30 	mvi r2,48
     604:	f8 00 02 30 	calli ec4 <writeReg>
	writeReg( TReloadRegH, 0x0 );//WWWWWWWWWARNING: colocar ambo ceros o revisar que hace el registro
     608:	34 01 00 58 	mvi r1,88
     60c:	34 02 00 00 	mvi r2,0
     610:	f8 00 02 2d 	calli ec4 <writeReg>
	writeReg( TxAutoReg, 0x40 );    //100%ASK
     614:	34 01 00 2a 	mvi r1,42
     618:	34 02 00 40 	mvi r2,64
     61c:	f8 00 02 2a 	calli ec4 <writeReg>
	writeReg( ModeReg, 0x3D );
     620:	34 01 00 22 	mvi r1,34
     624:	34 02 00 3d 	mvi r2,61
     628:	f8 00 02 27 	calli ec4 <writeReg>

	//AntennaON
	Set_Bit( TxControlReg, 0x03 );
     62c:	34 01 00 28 	mvi r1,40
     630:	34 02 00 03 	mvi r2,3
     634:	fb ff ff b4 	calli 504 <Set_Bit>

	//FIN_INIT
}
     638:	2b 9d 00 04 	lw ra,(sp+4)
     63c:	37 9c 00 04 	addi sp,sp,4
     640:	c3 a0 00 00 	ret

00000644 <toCard>:

bool toCard(int *info, int lengthData, int ID0, int ID1, int ID2, int ID3)
{
     644:	37 9c ff dc 	addi sp,sp,-36
     648:	5b 8b 00 20 	sw (sp+32),r11
     64c:	5b 8c 00 1c 	sw (sp+28),r12
     650:	5b 8d 00 18 	sw (sp+24),r13
     654:	5b 8e 00 14 	sw (sp+20),r14
     658:	5b 8f 00 10 	sw (sp+16),r15
     65c:	5b 90 00 0c 	sw (sp+12),r16
     660:	5b 91 00 08 	sw (sp+8),r17
     664:	5b 9d 00 04 	sw (sp+4),ra
     668:	b8 20 58 00 	mv r11,r1
	uint32_t i;
	char irqEn = 0x77;
	writeintXX(irqEn);//Serial.println(irqEn, HEX);
     66c:	34 01 00 77 	mvi r1,119

	//FIN_INIT
}

bool toCard(int *info, int lengthData, int ID0, int ID1, int ID2, int ID3)
{
     670:	b8 40 68 00 	mv r13,r2
	uint32_t i;
	char irqEn = 0x77;
	writeintXX(irqEn);//Serial.println(irqEn, HEX);
     674:	fb ff ff 72 	calli 43c <writeintXX>
	writeReg( ComIEnReg, irqEn | 0x80 );
     678:	34 01 00 04 	mvi r1,4
     67c:	34 02 00 f7 	mvi r2,247
     680:	f8 00 02 11 	calli ec4 <writeReg>
	newLine(); //SALTO
     684:	fb ff ff c7 	calli 5a0 <newLine>
	Clear_Bit( ComIrqReg, 0x80 );
     688:	34 01 00 08 	mvi r1,8
     68c:	34 02 00 80 	mvi r2,128
     690:	fb ff ff b0 	calli 550 <Clear_Bit>
	Set_Bit( FIFOLevelReg, 0x80 );
     694:	34 02 00 80 	mvi r2,128
     698:	34 01 00 14 	mvi r1,20
     69c:	fb ff ff 9a 	calli 504 <Set_Bit>
	uart_putstr("Escribe: ");
     6a0:	78 01 00 00 	mvhi r1,0x0
     6a4:	38 21 10 bc 	ori r1,r1,0x10bc
     6a8:	f8 00 01 fa 	calli e90 <uart_putstr>
	writeReg( CommandReg, PCD_IDLE );
     6ac:	34 01 00 02 	mvi r1,2
     6b0:	34 02 00 00 	mvi r2,0
     6b4:	f8 00 02 04 	calli ec4 <writeReg>
	for(i = 0; i < lengthData; i++){		//Escribe en el RFID FIFORreg los datos de info
     6b8:	45 a0 00 0a 	be r13,r0,6e0 <toCard+0x9c>
     6bc:	34 0c 00 00 	mvi r12,0
		writeReg(FIFODataReg, *info);
     6c0:	29 62 00 00 	lw r2,(r11+0)
     6c4:	34 01 00 12 	mvi r1,18
	newLine(); //SALTO
	Clear_Bit( ComIrqReg, 0x80 );
	Set_Bit( FIFOLevelReg, 0x80 );
	uart_putstr("Escribe: ");
	writeReg( CommandReg, PCD_IDLE );
	for(i = 0; i < lengthData; i++){		//Escribe en el RFID FIFORreg los datos de info
     6c8:	35 8c 00 01 	addi r12,r12,1
		writeReg(FIFODataReg, *info);
     6cc:	f8 00 01 fe 	calli ec4 <writeReg>
		writeintXX(*info);
     6d0:	29 61 00 00 	lw r1,(r11+0)
		info++;
     6d4:	35 6b 00 04 	addi r11,r11,4
	Set_Bit( FIFOLevelReg, 0x80 );
	uart_putstr("Escribe: ");
	writeReg( CommandReg, PCD_IDLE );
	for(i = 0; i < lengthData; i++){		//Escribe en el RFID FIFORreg los datos de info
		writeReg(FIFODataReg, *info);
		writeintXX(*info);
     6d8:	fb ff ff 59 	calli 43c <writeintXX>
	newLine(); //SALTO
	Clear_Bit( ComIrqReg, 0x80 );
	Set_Bit( FIFOLevelReg, 0x80 );
	uart_putstr("Escribe: ");
	writeReg( CommandReg, PCD_IDLE );
	for(i = 0; i < lengthData; i++){		//Escribe en el RFID FIFORreg los datos de info
     6dc:	55 ac ff f9 	bgu r13,r12,6c0 <toCard+0x7c>
		writeReg(FIFODataReg, *info);
		writeintXX(*info);
		info++;
	}
	//writeReg( FIFODataReg, 0x26 ); //EScribiendo
	writeReg( CommandReg, PCD_TRANSCEIVE );
     6e0:	34 01 00 02 	mvi r1,2
     6e4:	34 02 00 0c 	mvi r2,12
     6e8:	f8 00 01 f7 	calli ec4 <writeReg>
	Set_Bit( BitFramingReg, 0x80 );
     6ec:	34 01 00 1a 	mvi r1,26
     6f0:	34 02 00 80 	mvi r2,128
     6f4:	78 0d 00 00 	mvhi r13,0x0
				
		uart_putstr("entro a verificar");//Serial.println("Entro a verificar");
		newLine();
		n = readReg( ComIrqReg );
		if(n & waitIrq){
			uart_putstr("ha cambiado algo");//Serial.println("ha cambiado algo");
     6f8:	78 11 00 00 	mvhi r17,0x0
			flag = false;
			status = true;
			newLine(); //SALTO
		}
		if(n & 0x01){
			uart_putstr("TIMEOUT, nada en 25ms");//Serial.println("TIMEOUT, nada en 25ms");
     6fc:	78 10 00 00 	mvhi r16,0x0
		writeintXX(*info);
		info++;
	}
	//writeReg( FIFODataReg, 0x26 ); //EScribiendo
	writeReg( CommandReg, PCD_TRANSCEIVE );
	Set_Bit( BitFramingReg, 0x80 );
     700:	fb ff ff 81 	calli 504 <Set_Bit>
	char waitIrq = 0x30;
	
	volatile uint32_t cont;
	
	bool flag = true;
	bool status = false;
     704:	34 0f 00 00 	mvi r15,0
		info++;
	}
	//writeReg( FIFODataReg, 0x26 ); //EScribiendo
	writeReg( CommandReg, PCD_TRANSCEIVE );
	Set_Bit( BitFramingReg, 0x80 );
	newLine(); //SALTO
     708:	fb ff ff a6 	calli 5a0 <newLine>
     70c:	39 ad 10 c8 	ori r13,r13,0x10c8
				
		uart_putstr("entro a verificar");//Serial.println("Entro a verificar");
		newLine();
		n = readReg( ComIrqReg );
		if(n & waitIrq){
			uart_putstr("ha cambiado algo");//Serial.println("ha cambiado algo");
     710:	3a 31 10 dc 	ori r17,r17,0x10dc
			flag = false;
			status = true;
			newLine(); //SALTO
		}
		if(n & 0x01){
			uart_putstr("TIMEOUT, nada en 25ms");//Serial.println("TIMEOUT, nada en 25ms");
     714:	3a 10 10 f0 	ori r16,r16,0x10f0
			flag=false;
			status = false;//RETURN
		}
		if(cont == 1000){
     718:	34 0e 03 e8 	mvi r14,1000
     71c:	e0 00 00 0a 	bi 744 <toCard+0x100>
			uart_putstr("ha cambiado algo");//Serial.println("ha cambiado algo");
			flag = false;
			status = true;
			newLine(); //SALTO
		}
		if(n & 0x01){
     720:	21 62 00 01 	andi r2,r11,0x1
     724:	5c 40 00 18 	bne r2,r0,784 <toCard+0x140>
			uart_putstr("TIMEOUT, nada en 25ms");//Serial.println("TIMEOUT, nada en 25ms");
			flag=false;
			status = false;//RETURN
		}
		if(cont == 1000){
     728:	2b 82 00 24 	lw r2,(sp+36)
     72c:	44 4e 00 1c 	be r2,r14,79c <toCard+0x158>
			uart_putstr("terminó de contar");
			flag = false;
			status = false;
		}
		cont = cont + 1;
     730:	2b 82 00 24 	lw r2,(sp+36)
     734:	34 42 00 01 	addi r2,r2,1
     738:	5b 82 00 24 	sw (sp+36),r2
		//for(cont = 0; cont < 1000; cont++);//{ //cont < 333334
			//flag = false;
			//writeint(cont);
		newLine();
     73c:	fb ff ff 99 	calli 5a0 <newLine>
	
	volatile uint32_t cont;
	
	bool flag = true;
	bool status = false;
	while(flag){
     740:	45 80 00 1f 	be r12,r0,7bc <toCard+0x178>
				
		uart_putstr("entro a verificar");//Serial.println("Entro a verificar");
     744:	b9 a0 08 00 	mv r1,r13
     748:	f8 00 01 d2 	calli e90 <uart_putstr>
		newLine();
     74c:	fb ff ff 95 	calli 5a0 <newLine>
		n = readReg( ComIrqReg );
     750:	34 01 00 08 	mvi r1,8
     754:	f8 00 01 e6 	calli eec <readReg>
     758:	20 2b 00 ff 	andi r11,r1,0xff
		if(n & waitIrq){
     75c:	21 62 00 30 	andi r2,r11,0x30
     760:	34 0c 00 01 	mvi r12,1
     764:	44 40 ff ef 	be r2,r0,720 <toCard+0xdc>
			uart_putstr("ha cambiado algo");//Serial.println("ha cambiado algo");
     768:	ba 20 08 00 	mv r1,r17
     76c:	f8 00 01 c9 	calli e90 <uart_putstr>
			flag = false;
			status = true;
			newLine(); //SALTO
     770:	fb ff ff 8c 	calli 5a0 <newLine>
		}
		if(n & 0x01){
     774:	21 62 00 01 	andi r2,r11,0x1
		uart_putstr("entro a verificar");//Serial.println("Entro a verificar");
		newLine();
		n = readReg( ComIrqReg );
		if(n & waitIrq){
			uart_putstr("ha cambiado algo");//Serial.println("ha cambiado algo");
			flag = false;
     778:	34 0c 00 00 	mvi r12,0
			status = true;
     77c:	34 0f 00 01 	mvi r15,1
			newLine(); //SALTO
		}
		if(n & 0x01){
     780:	44 40 ff ea 	be r2,r0,728 <toCard+0xe4>
			uart_putstr("TIMEOUT, nada en 25ms");//Serial.println("TIMEOUT, nada en 25ms");
     784:	ba 00 08 00 	mv r1,r16
     788:	f8 00 01 c2 	calli e90 <uart_putstr>
			flag=false;
			status = false;//RETURN
		}
		if(cont == 1000){
     78c:	2b 82 00 24 	lw r2,(sp+36)
			status = true;
			newLine(); //SALTO
		}
		if(n & 0x01){
			uart_putstr("TIMEOUT, nada en 25ms");//Serial.println("TIMEOUT, nada en 25ms");
			flag=false;
     790:	34 0c 00 00 	mvi r12,0
			status = false;//RETURN
     794:	34 0f 00 00 	mvi r15,0
		}
		if(cont == 1000){
     798:	5c 4e ff e6 	bne r2,r14,730 <toCard+0xec>
			uart_putstr("terminó de contar");
     79c:	78 01 00 00 	mvhi r1,0x0
     7a0:	38 21 11 08 	ori r1,r1,0x1108
     7a4:	f8 00 01 bb 	calli e90 <uart_putstr>
			flag = false;
			status = false;
		}
		cont = cont + 1;
     7a8:	2b 81 00 24 	lw r1,(sp+36)
			status = false;//RETURN
		}
		if(cont == 1000){
			uart_putstr("terminó de contar");
			flag = false;
			status = false;
     7ac:	34 0f 00 00 	mvi r15,0
		}
		cont = cont + 1;
     7b0:	34 21 00 01 	addi r1,r1,1
     7b4:	5b 81 00 24 	sw (sp+36),r1
		//for(cont = 0; cont < 1000; cont++);//{ //cont < 333334
			//flag = false;
			//writeint(cont);
		newLine();
     7b8:	fb ff ff 7a 	calli 5a0 <newLine>
		//flag = false;
		//delay(1);
	}
	flag=true;
	//uart_putstr("salio del ciclo");
	newLine(); //SALTO
     7bc:	fb ff ff 79 	calli 5a0 <newLine>

	Clear_Bit( BitFramingReg, 0x80 );
     7c0:	34 02 00 80 	mvi r2,128
     7c4:	34 01 00 1a 	mvi r1,26
     7c8:	fb ff ff 62 	calli 550 <Clear_Bit>
	char lec;
	lec = readReg( ErrorReg);
     7cc:	34 01 00 0c 	mvi r1,12
     7d0:	f8 00 01 c7 	calli eec <readReg>
     7d4:	20 2d 00 ff 	andi r13,r1,0xff
	newLine(); //SALTO
	if( !( lec & 0x1B) ){
     7d8:	21 ac 00 1b 	andi r12,r13,0x1b
	newLine(); //SALTO

	Clear_Bit( BitFramingReg, 0x80 );
	char lec;
	lec = readReg( ErrorReg);
	newLine(); //SALTO
     7dc:	fb ff ff 71 	calli 5a0 <newLine>
	if( !( lec & 0x1B) ){
     7e0:	5d 80 00 09 	bne r12,r0,804 <toCard+0x1c0>
		writeintXX(lec);//Serial.println(lec, HEX);
     7e4:	b9 a0 08 00 	mv r1,r13
     7e8:	fb ff ff 15 	calli 43c <writeintXX>
		uart_putstr("status=MI_OK, todo va bien");//Serial.println("status=MI_OK, todo va bien");
     7ec:	78 01 00 00 	mvhi r1,0x0
     7f0:	38 21 11 1c 	ori r1,r1,0x111c
		//status = true;
		newLine(); //SALTO
	
		if ( n & irqEn & 0x01 ){// WWWWWWWWARNING: Parece ser otra lectura de un posible error, pero pues
     7f4:	21 6b 00 01 	andi r11,r11,0x1
	char lec;
	lec = readReg( ErrorReg);
	newLine(); //SALTO
	if( !( lec & 0x1B) ){
		writeintXX(lec);//Serial.println(lec, HEX);
		uart_putstr("status=MI_OK, todo va bien");//Serial.println("status=MI_OK, todo va bien");
     7f8:	f8 00 01 a6 	calli e90 <uart_putstr>
		//status = true;
		newLine(); //SALTO
     7fc:	fb ff ff 69 	calli 5a0 <newLine>
	
		if ( n & irqEn & 0x01 ){// WWWWWWWWARNING: Parece ser otra lectura de un posible error, pero pues
     800:	5d 6c 00 36 	bne r11,r12,8d8 <toCard+0x294>
			status = false;//RETURN
			newLine(); //SALTO
			return status;
		}
	}
	n = readReg(FIFOLevelReg); //leer cantidad de datos
     804:	34 01 00 14 	mvi r1,20
     808:	f8 00 01 b9 	calli eec <readReg>
	uart_putstr("la cantidad de datos n a leer es: ");//Serial.print("la cantidad de datos n a leer es: ");
     80c:	78 02 00 00 	mvhi r2,0x0
			status = false;//RETURN
			newLine(); //SALTO
			return status;
		}
	}
	n = readReg(FIFOLevelReg); //leer cantidad de datos
     810:	b8 20 68 00 	mv r13,r1
	uart_putstr("la cantidad de datos n a leer es: ");//Serial.print("la cantidad de datos n a leer es: ");
     814:	b8 40 08 00 	mv r1,r2
     818:	38 21 11 5c 	ori r1,r1,0x115c
     81c:	f8 00 01 9d 	calli e90 <uart_putstr>
	writeintXX(n);
     820:	21 ad 00 ff 	andi r13,r13,0xff
     824:	b9 a0 08 00 	mv r1,r13
	uart_putstr("---------");//Serial.print(n, BIN); Serial.println("----");
     828:	78 10 00 00 	mvhi r16,0x0
			return status;
		}
	}
	n = readReg(FIFOLevelReg); //leer cantidad de datos
	uart_putstr("la cantidad de datos n a leer es: ");//Serial.print("la cantidad de datos n a leer es: ");
	writeintXX(n);
     82c:	fb ff ff 04 	calli 43c <writeintXX>
	uart_putstr("---------");//Serial.print(n, BIN); Serial.println("----");
     830:	3a 10 11 80 	ori r16,r16,0x1180
     834:	ba 00 08 00 	mv r1,r16
     838:	f8 00 01 96 	calli e90 <uart_putstr>
	newLine(); //SALTO
     83c:	fb ff ff 59 	calli 5a0 <newLine>
	
	
	for(i=0 ;i < n; i++){   //WWWWWWWWWARNING: Tener en cuenta para la FPGA, colocar un if(n == 0) o algo asi, para evitar que lea inecesariamente si no hay datos que leer
     840:	45 a0 00 0e 	be r13,r0,878 <toCard+0x234>
     844:	78 0e 00 00 	mvhi r14,0x0
     848:	34 0b 00 00 	mvi r11,0
     84c:	39 ce 11 8c 	ori r14,r14,0x118c
		lec = readReg(FIFODataReg);
     850:	34 01 00 12 	mvi r1,18
     854:	f8 00 01 a6 	calli eec <readReg>
     858:	b8 20 60 00 	mv r12,r1
		ID2=lec;
		}
		if(i==3){
		ID3=lec;
		}
		uart_putstr(" Dato leido de FIFO: ");//Serial.print(" Dato leido de FIFO: ");
     85c:	b9 c0 08 00 	mv r1,r14
     860:	f8 00 01 8c 	calli e90 <uart_putstr>
		writeintXX(lec);//Serial.print(lec, HEX);
     864:	21 81 00 ff 	andi r1,r12,0xff
	writeintXX(n);
	uart_putstr("---------");//Serial.print(n, BIN); Serial.println("----");
	newLine(); //SALTO
	
	
	for(i=0 ;i < n; i++){   //WWWWWWWWWARNING: Tener en cuenta para la FPGA, colocar un if(n == 0) o algo asi, para evitar que lea inecesariamente si no hay datos que leer
     868:	35 6b 00 01 	addi r11,r11,1
		}
		if(i==3){
		ID3=lec;
		}
		uart_putstr(" Dato leido de FIFO: ");//Serial.print(" Dato leido de FIFO: ");
		writeintXX(lec);//Serial.print(lec, HEX);
     86c:	fb ff fe f4 	calli 43c <writeintXX>
		newLine(); //SALTO
     870:	fb ff ff 4c 	calli 5a0 <newLine>
	writeintXX(n);
	uart_putstr("---------");//Serial.print(n, BIN); Serial.println("----");
	newLine(); //SALTO
	
	
	for(i=0 ;i < n; i++){   //WWWWWWWWWARNING: Tener en cuenta para la FPGA, colocar un if(n == 0) o algo asi, para evitar que lea inecesariamente si no hay datos que leer
     874:	55 ab ff f7 	bgu r13,r11,850 <toCard+0x20c>
		}
		uart_putstr(" Dato leido de FIFO: ");//Serial.print(" Dato leido de FIFO: ");
		writeintXX(lec);//Serial.print(lec, HEX);
		newLine(); //SALTO
	}
	uart_putstr("---------");//Serial.println("----");
     878:	ba 00 08 00 	mv r1,r16
     87c:	f8 00 01 85 	calli e90 <uart_putstr>
	newLine(); //SALTO
     880:	fb ff ff 48 	calli 5a0 <newLine>
	int validBits;
	validBits = readReg(ControlReg) & 0x07; //Ver nro de bits validos
     884:	34 01 00 18 	mvi r1,24
     888:	f8 00 01 99 	calli eec <readReg>
	uart_putstr("Bits validos");//Serial.print("Bits validos");Serial.print(validBits, BIN);
     88c:	78 02 00 00 	mvhi r2,0x0
		newLine(); //SALTO
	}
	uart_putstr("---------");//Serial.println("----");
	newLine(); //SALTO
	int validBits;
	validBits = readReg(ControlReg) & 0x07; //Ver nro de bits validos
     890:	b8 20 58 00 	mv r11,r1
	uart_putstr("Bits validos");//Serial.print("Bits validos");Serial.print(validBits, BIN);
     894:	b8 40 08 00 	mv r1,r2
     898:	38 21 11 a4 	ori r1,r1,0x11a4
     89c:	f8 00 01 7d 	calli e90 <uart_putstr>
	writeintXX(validBits);
     8a0:	21 61 00 07 	andi r1,r11,0x7
     8a4:	fb ff fe e6 	calli 43c <writeintXX>
	newLine();
     8a8:	fb ff ff 3e 	calli 5a0 <newLine>
	return status;
	//Serial.println();

	//FIN TO_CARD
}
     8ac:	b9 e0 08 00 	mv r1,r15
     8b0:	2b 9d 00 04 	lw ra,(sp+4)
     8b4:	2b 8b 00 20 	lw r11,(sp+32)
     8b8:	2b 8c 00 1c 	lw r12,(sp+28)
     8bc:	2b 8d 00 18 	lw r13,(sp+24)
     8c0:	2b 8e 00 14 	lw r14,(sp+20)
     8c4:	2b 8f 00 10 	lw r15,(sp+16)
     8c8:	2b 90 00 0c 	lw r16,(sp+12)
     8cc:	2b 91 00 08 	lw r17,(sp+8)
     8d0:	37 9c 00 24 	addi sp,sp,36
     8d4:	c3 a0 00 00 	ret
		uart_putstr("status=MI_OK, todo va bien");//Serial.println("status=MI_OK, todo va bien");
		//status = true;
		newLine(); //SALTO
	
		if ( n & irqEn & 0x01 ){// WWWWWWWWARNING: Parece ser otra lectura de un posible error, pero pues
			uart_putstr("status=NOTAGERR, NO todo va bien");//
     8d8:	78 01 00 00 	mvhi r1,0x0
     8dc:	38 21 11 38 	ori r1,r1,0x1138
     8e0:	f8 00 01 6c 	calli e90 <uart_putstr>
			status = false;//RETURN
			newLine(); //SALTO
			return status;
     8e4:	34 0f 00 00 	mvi r15,0
		newLine(); //SALTO
	
		if ( n & irqEn & 0x01 ){// WWWWWWWWARNING: Parece ser otra lectura de un posible error, pero pues
			uart_putstr("status=NOTAGERR, NO todo va bien");//
			status = false;//RETURN
			newLine(); //SALTO
     8e8:	fb ff ff 2e 	calli 5a0 <newLine>
			return status;
     8ec:	e3 ff ff f0 	bi 8ac <toCard+0x268>

000008f0 <isCard>:

	//FIN TO_CARD
}

bool isCard()
{
     8f0:	37 9c ff f8 	addi sp,sp,-8
     8f4:	5b 9d 00 04 	sw (sp+4),ra
int x;
	int request[] = {0x26};
     8f8:	34 03 00 26 	mvi r3,38
	bool status;
	//IS_CARD

	//REQUEST

	writeReg( BitFramingReg, 0x07 );
     8fc:	34 02 00 07 	mvi r2,7
     900:	34 01 00 1a 	mvi r1,26
}

bool isCard()
{
int x;
	int request[] = {0x26};
     904:	5b 83 00 08 	sw (sp+8),r3
	bool status;
	//IS_CARD

	//REQUEST

	writeReg( BitFramingReg, 0x07 );
     908:	f8 00 01 6f 	calli ec4 <writeReg>

	status = toCard(&request, 1,x,x,x,x);
     90c:	34 03 00 00 	mvi r3,0
     910:	37 81 00 08 	addi r1,sp,8
     914:	34 02 00 01 	mvi r2,1
     918:	b8 60 20 00 	mv r4,r3
     91c:	b8 60 28 00 	mv r5,r3
     920:	b8 60 30 00 	mv r6,r3
     924:	fb ff ff 48 	calli 644 <toCard>
	return status;
	//FIN REQUEST
	//FIN IS_CARD
}
     928:	2b 9d 00 04 	lw ra,(sp+4)
     92c:	37 9c 00 08 	addi sp,sp,8
     930:	c3 a0 00 00 	ret

00000934 <getUIDCard>:

int* getUIDCard()
{
     934:	37 9c ff e4 	addi sp,sp,-28
     938:	5b 9d 00 04 	sw (sp+4),ra
int ID1;
int ID2;
int ID3;


	int UIDRead[] = {0x93, 0x20};
     93c:	34 03 00 93 	mvi r3,147
     940:	5b 83 00 18 	sw (sp+24),r3
	//READ_CARD_SERIAL

	//ANTICOLL
	writeReg( BitFramingReg, 0x00 );
     944:	34 01 00 1a 	mvi r1,26
int ID1;
int ID2;
int ID3;


	int UIDRead[] = {0x93, 0x20};
     948:	34 03 00 20 	mvi r3,32
	//READ_CARD_SERIAL

	//ANTICOLL
	writeReg( BitFramingReg, 0x00 );
     94c:	34 02 00 00 	mvi r2,0
int ID1;
int ID2;
int ID3;


	int UIDRead[] = {0x93, 0x20};
     950:	5b 83 00 1c 	sw (sp+28),r3
	//READ_CARD_SERIAL

	//ANTICOLL
	writeReg( BitFramingReg, 0x00 );
     954:	f8 00 01 5c 	calli ec4 <writeReg>
	Clear_Bit( Status2Reg, 0x08 );//WWWWWWWWARGNING: no presente en anterior ejemplo del cuaderno, tal vez puede ser omitido
     958:	34 01 00 10 	mvi r1,16
     95c:	34 02 00 08 	mvi r2,8
     960:	fb ff fe fc 	calli 550 <Clear_Bit>
	newLine(); //SALTO
     964:	fb ff ff 0f 	calli 5a0 <newLine>
	toCard(&UIDRead, 2,ID0, ID1, ID2, ID3);
     968:	37 81 00 18 	addi r1,sp,24
     96c:	34 02 00 02 	mvi r2,2
     970:	34 03 00 00 	mvi r3,0
     974:	34 04 00 00 	mvi r4,0
     978:	34 05 00 00 	mvi r5,0
     97c:	34 06 00 00 	mvi r6,0
     980:	fb ff ff 31 	calli 644 <toCard>
	
	int identificacion[4] = {ID0, ID1, ID2, ID3};
int *p=identificacion;
	return p;
	//FIN READ_CARD_SERIAL
}
     984:	37 81 00 08 	addi r1,sp,8
     988:	2b 9d 00 04 	lw ra,(sp+4)
     98c:	37 9c 00 1c 	addi sp,sp,28
     990:	c3 a0 00 00 	ret

00000994 <main>:
int Y = 0b01011001101;
int Z = 0b01011010101;
int ESPACIO = 0b00010000101;

int main()
{
     994:	37 9c ff 30 	addi sp,sp,-208
     998:	5b 8b 00 c8 	sw (sp+200),r11
     99c:	5b 8c 00 c4 	sw (sp+196),r12
     9a0:	5b 8d 00 c0 	sw (sp+192),r13
     9a4:	5b 8e 00 bc 	sw (sp+188),r14
     9a8:	5b 8f 00 b8 	sw (sp+184),r15
     9ac:	5b 90 00 b4 	sw (sp+180),r16
     9b0:	5b 91 00 b0 	sw (sp+176),r17
     9b4:	5b 92 00 ac 	sw (sp+172),r18
     9b8:	5b 93 00 a8 	sw (sp+168),r19
     9bc:	5b 94 00 a4 	sw (sp+164),r20
     9c0:	5b 95 00 a0 	sw (sp+160),r21
     9c4:	5b 96 00 9c 	sw (sp+156),r22
     9c8:	5b 97 00 98 	sw (sp+152),r23
     9cc:	5b 98 00 94 	sw (sp+148),r24
     9d0:	5b 99 00 90 	sw (sp+144),r25
     9d4:	5b 9b 00 8c 	sw (sp+140),fp
     9d8:	5b 9d 00 88 	sw (sp+136),ra
     9dc:	78 01 00 00 	mvhi r1,0x0
     9e0:	78 02 00 00 	mvhi r2,0x0
     9e4:	78 13 00 00 	mvhi r19,0x0
     9e8:	78 12 00 00 	mvhi r18,0x0
     9ec:	78 11 00 00 	mvhi r17,0x0
     9f0:	78 10 00 00 	mvhi r16,0x0
     9f4:	78 0f 00 00 	mvhi r15,0x0
     9f8:	78 15 00 00 	mvhi r21,0x0
     9fc:	78 14 00 00 	mvhi r20,0x0
     a00:	78 1b 00 00 	mvhi fp,0x0
     a04:	78 19 00 00 	mvhi r25,0x0
     a08:	78 18 00 00 	mvhi r24,0x0
     a0c:	78 17 00 00 	mvhi r23,0x0
     a10:	78 16 00 00 	mvhi r22,0x0
     a14:	38 21 12 28 	ori r1,r1,0x1228
     a18:	38 42 12 00 	ori r2,r2,0x1200
     a1c:	3a 73 12 48 	ori r19,r19,0x1248
     a20:	3a 52 11 cc 	ori r18,r18,0x11cc
     a24:	3a 31 11 d0 	ori r17,r17,0x11d0
     a28:	3a 10 11 d4 	ori r16,r16,0x11d4
     a2c:	5b 81 00 d0 	sw (sp+208),r1
     a30:	5b 82 00 cc 	sw (sp+204),r2
     a34:	39 ef 11 dc 	ori r15,r15,0x11dc
     a38:	3a b5 12 14 	ori r21,r21,0x1214
     a3c:	3a 94 12 18 	ori r20,r20,0x1218
     a40:	3b 7b 12 2c 	ori fp,fp,0x122c
     a44:	3b 39 11 f0 	ori r25,r25,0x11f0
     a48:	3b 18 11 e8 	ori r24,r24,0x11e8
     a4c:	3a f7 12 0c 	ori r23,r23,0x120c
     a50:	3a d6 11 e0 	ori r22,r22,0x11e0
		initRFID();
	}*/
	while(1){
		
		int teclaoprimida = Leerteclado();
		if(teclaoprimida == 3){
     a54:	34 0e 00 03 	mvi r14,3
     a58:	e0 00 00 3d 	bi b4c <main+0x1b8>
				writelcd(19,inicializar1,inicializar2,inicializar3,ESPACIO,ESPACIO,ESPACIO,ESPACIO,ESPACIO,ESPACIO,ESPACIO,ESPACIO,S,I,ESPACIO,ESPACIO,ESPACIO,ESPACIO,ESPACIO,ubicarlinea2, ESPACIO,ESPACIO,ESPACIO,ESPACIO,ESPACIO,ESPACIO,ESPACIO,ESPACIO,ESPACIO,ESPACIO,ESPACIO,1,2,3,4,5,6,7,8,9,10);	// 19 numero instrucciones a ejecutar
			}else{
				writelcd(19,inicializar1,inicializar2,inicializar3,ESPACIO,ESPACIO,ESPACIO,ESPACIO,ESPACIO,ESPACIO,ESPACIO,ESPACIO,N,O, ESPACIO,ESPACIO,ESPACIO,ESPACIO,ESPACIO,ubicarlinea2, ESPACIO,ESPACIO,ESPACIO,ESPACIO,ESPACIO,ESPACIO,ESPACIO,ESPACIO,ESPACIO,ESPACIO,ESPACIO,1,2,3,4,5,6,7,8,9,10);	
			}
		}else{
			writelcd(19,inicializar1,inicializar2,inicializar3,ESPACIO,ESPACIO,ESPACIO,ESPACIO,N,O,ESPACIO,T,E,C,L,A,ESPACIO,ESPACIO,ESPACIO,ubicarlinea2, ESPACIO,ESPACIO,ESPACIO,ESPACIO,ESPACIO,ESPACIO,ESPACIO,ESPACIO,ESPACIO,ESPACIO,ESPACIO,1,2,3,4,5,6,7,8,9,10);	
     a5c:	2b 6c 00 00 	lw r12,(fp+0)
     a60:	2a 69 00 00 	lw r9,(r19+0)
     a64:	2a a6 00 00 	lw r6,(r21+0)
     a68:	2a 81 00 00 	lw r1,(r20+0)
     a6c:	2a e8 00 00 	lw r8,(r23+0)
     a70:	2a c7 00 00 	lw r7,(r22+0)
     a74:	2b 2b 00 00 	lw r11,(r25+0)
     a78:	2b 0a 00 00 	lw r10,(r24+0)
     a7c:	29 ed 00 00 	lw r13,(r15+0)
     a80:	5b 86 00 04 	sw (sp+4),r6
     a84:	5b 81 00 08 	sw (sp+8),r1
     a88:	5b 89 00 0c 	sw (sp+12),r9
     a8c:	5b 88 00 1c 	sw (sp+28),r8
     a90:	5b 87 00 20 	sw (sp+32),r7
     a94:	5b 89 00 24 	sw (sp+36),r9
     a98:	5b 89 00 28 	sw (sp+40),r9
     a9c:	5b 89 00 2c 	sw (sp+44),r9
     aa0:	5b 89 00 34 	sw (sp+52),r9
     aa4:	5b 89 00 38 	sw (sp+56),r9
     aa8:	5b 89 00 3c 	sw (sp+60),r9
     aac:	5b 89 00 40 	sw (sp+64),r9
     ab0:	5b 89 00 44 	sw (sp+68),r9
     ab4:	5b 89 00 48 	sw (sp+72),r9
     ab8:	5b 89 00 4c 	sw (sp+76),r9
     abc:	5b 89 00 50 	sw (sp+80),r9
     ac0:	5b 89 00 54 	sw (sp+84),r9
     ac4:	5b 8c 00 10 	sw (sp+16),r12
     ac8:	5b 8b 00 14 	sw (sp+20),r11
     acc:	5b 8a 00 18 	sw (sp+24),r10
     ad0:	5b 8d 00 30 	sw (sp+48),r13
     ad4:	2a 42 00 00 	lw r2,(r18+0)
     ad8:	2a 23 00 00 	lw r3,(r17+0)
     adc:	2a 04 00 00 	lw r4,(r16+0)
     ae0:	b9 20 28 00 	mv r5,r9
     ae4:	5b 89 00 58 	sw (sp+88),r9
     ae8:	b9 20 30 00 	mv r6,r9
     aec:	b9 20 38 00 	mv r7,r9
     af0:	b9 20 40 00 	mv r8,r9
     af4:	5b 89 00 5c 	sw (sp+92),r9
     af8:	34 09 00 01 	mvi r9,1
     afc:	5b 89 00 60 	sw (sp+96),r9
     b00:	34 09 00 02 	mvi r9,2
     b04:	34 01 00 13 	mvi r1,19
     b08:	5b 89 00 64 	sw (sp+100),r9
     b0c:	5b 8e 00 68 	sw (sp+104),r14
     b10:	34 09 00 04 	mvi r9,4
     b14:	5b 89 00 6c 	sw (sp+108),r9
     b18:	34 09 00 05 	mvi r9,5
     b1c:	5b 89 00 70 	sw (sp+112),r9
     b20:	34 09 00 06 	mvi r9,6
     b24:	5b 89 00 74 	sw (sp+116),r9
     b28:	34 09 00 07 	mvi r9,7
     b2c:	5b 89 00 78 	sw (sp+120),r9
     b30:	34 09 00 08 	mvi r9,8
     b34:	5b 89 00 7c 	sw (sp+124),r9
     b38:	34 09 00 09 	mvi r9,9
     b3c:	5b 89 00 80 	sw (sp+128),r9
     b40:	34 09 00 0a 	mvi r9,10
     b44:	5b 89 00 84 	sw (sp+132),r9
     b48:	f8 00 00 f9 	calli f2c <writelcd>
		uart_getchar();
		initRFID();
	}*/
	while(1){
		
		int teclaoprimida = Leerteclado();
     b4c:	f8 00 01 51 	calli 1090 <Leerteclado>
		if(teclaoprimida == 3){
     b50:	5c 2e ff c3 	bne r1,r14,a5c <main+0xc8>
			chooseRFID(0x00);
     b54:	34 01 00 00 	mvi r1,0
     b58:	f8 00 00 f0 	calli f18 <chooseRFID>
			initRFID();
     b5c:	fb ff fe 9a 	calli 5c4 <initRFID>
			bool status = isCard();
     b60:	fb ff ff 64 	calli 8f0 <isCard>
			if( status == true){
     b64:	34 05 00 01 	mvi r5,1
     b68:	44 25 00 2a 	be r1,r5,c10 <main+0x27c>
				getUIDCard();
				writelcd(19,inicializar1,inicializar2,inicializar3,ESPACIO,ESPACIO,ESPACIO,ESPACIO,ESPACIO,ESPACIO,ESPACIO,ESPACIO,S,I,ESPACIO,ESPACIO,ESPACIO,ESPACIO,ESPACIO,ubicarlinea2, ESPACIO,ESPACIO,ESPACIO,ESPACIO,ESPACIO,ESPACIO,ESPACIO,ESPACIO,ESPACIO,ESPACIO,ESPACIO,1,2,3,4,5,6,7,8,9,10);	// 19 numero instrucciones a ejecutar
			}else{
				writelcd(19,inicializar1,inicializar2,inicializar3,ESPACIO,ESPACIO,ESPACIO,ESPACIO,ESPACIO,ESPACIO,ESPACIO,ESPACIO,N,O, ESPACIO,ESPACIO,ESPACIO,ESPACIO,ESPACIO,ubicarlinea2, ESPACIO,ESPACIO,ESPACIO,ESPACIO,ESPACIO,ESPACIO,ESPACIO,ESPACIO,ESPACIO,ESPACIO,ESPACIO,1,2,3,4,5,6,7,8,9,10);	
     b6c:	2a 61 00 00 	lw r1,(r19+0)
     b70:	2a a7 00 00 	lw r7,(r21+0)
     b74:	2a 86 00 00 	lw r6,(r20+0)
     b78:	29 e8 00 00 	lw r8,(r15+0)
     b7c:	2a 42 00 00 	lw r2,(r18+0)
     b80:	2a 23 00 00 	lw r3,(r17+0)
     b84:	2a 04 00 00 	lw r4,(r16+0)
     b88:	b8 20 28 00 	mv r5,r1
     b8c:	5b 81 00 04 	sw (sp+4),r1
     b90:	5b 81 00 08 	sw (sp+8),r1
     b94:	5b 81 00 0c 	sw (sp+12),r1
     b98:	5b 81 00 10 	sw (sp+16),r1
     b9c:	5b 81 00 1c 	sw (sp+28),r1
     ba0:	5b 81 00 20 	sw (sp+32),r1
     ba4:	5b 81 00 24 	sw (sp+36),r1
     ba8:	5b 81 00 28 	sw (sp+40),r1
     bac:	5b 81 00 2c 	sw (sp+44),r1
     bb0:	5b 81 00 34 	sw (sp+52),r1
     bb4:	5b 81 00 38 	sw (sp+56),r1
     bb8:	5b 81 00 3c 	sw (sp+60),r1
     bbc:	5b 81 00 40 	sw (sp+64),r1
     bc0:	5b 81 00 44 	sw (sp+68),r1
     bc4:	5b 81 00 48 	sw (sp+72),r1
     bc8:	5b 81 00 4c 	sw (sp+76),r1
     bcc:	5b 81 00 50 	sw (sp+80),r1
     bd0:	5b 81 00 54 	sw (sp+84),r1
     bd4:	5b 81 00 58 	sw (sp+88),r1
     bd8:	5b 81 00 5c 	sw (sp+92),r1
     bdc:	34 09 00 02 	mvi r9,2
     be0:	34 01 00 01 	mvi r1,1
     be4:	5b 87 00 14 	sw (sp+20),r7
     be8:	5b 86 00 18 	sw (sp+24),r6
     bec:	5b 88 00 30 	sw (sp+48),r8
     bf0:	5b 81 00 60 	sw (sp+96),r1
     bf4:	5b 89 00 64 	sw (sp+100),r9
     bf8:	5b 8e 00 68 	sw (sp+104),r14
     bfc:	34 01 00 13 	mvi r1,19
     c00:	b8 a0 30 00 	mv r6,r5
     c04:	b8 a0 38 00 	mv r7,r5
     c08:	b8 a0 40 00 	mv r8,r5
     c0c:	e3 ff ff c1 	bi b10 <main+0x17c>
		if(teclaoprimida == 3){
			chooseRFID(0x00);
			initRFID();
			bool status = isCard();
			if( status == true){
				getUIDCard();
     c10:	fb ff ff 49 	calli 934 <getUIDCard>
				writelcd(19,inicializar1,inicializar2,inicializar3,ESPACIO,ESPACIO,ESPACIO,ESPACIO,ESPACIO,ESPACIO,ESPACIO,ESPACIO,S,I,ESPACIO,ESPACIO,ESPACIO,ESPACIO,ESPACIO,ubicarlinea2, ESPACIO,ESPACIO,ESPACIO,ESPACIO,ESPACIO,ESPACIO,ESPACIO,ESPACIO,ESPACIO,ESPACIO,ESPACIO,1,2,3,4,5,6,7,8,9,10);	// 19 numero instrucciones a ejecutar
     c14:	2b 89 00 d0 	lw r9,(sp+208)
     c18:	2b 85 00 cc 	lw r5,(sp+204)
     c1c:	2a 61 00 00 	lw r1,(r19+0)
     c20:	29 27 00 00 	lw r7,(r9+0)
     c24:	28 a6 00 00 	lw r6,(r5+0)
     c28:	29 e8 00 00 	lw r8,(r15+0)
     c2c:	34 09 00 01 	mvi r9,1
     c30:	5b 81 00 04 	sw (sp+4),r1
     c34:	5b 81 00 08 	sw (sp+8),r1
     c38:	5b 81 00 0c 	sw (sp+12),r1
     c3c:	5b 81 00 10 	sw (sp+16),r1
     c40:	5b 81 00 1c 	sw (sp+28),r1
     c44:	5b 81 00 20 	sw (sp+32),r1
     c48:	5b 81 00 24 	sw (sp+36),r1
     c4c:	5b 81 00 28 	sw (sp+40),r1
     c50:	5b 81 00 2c 	sw (sp+44),r1
     c54:	5b 81 00 34 	sw (sp+52),r1
     c58:	5b 81 00 38 	sw (sp+56),r1
     c5c:	5b 81 00 3c 	sw (sp+60),r1
     c60:	5b 81 00 40 	sw (sp+64),r1
     c64:	5b 81 00 44 	sw (sp+68),r1
     c68:	5b 81 00 48 	sw (sp+72),r1
     c6c:	5b 81 00 4c 	sw (sp+76),r1
     c70:	5b 81 00 50 	sw (sp+80),r1
     c74:	5b 81 00 54 	sw (sp+84),r1
     c78:	5b 81 00 58 	sw (sp+88),r1
     c7c:	5b 81 00 5c 	sw (sp+92),r1
     c80:	b8 20 28 00 	mv r5,r1
     c84:	5b 87 00 14 	sw (sp+20),r7
     c88:	5b 86 00 18 	sw (sp+24),r6
     c8c:	5b 88 00 30 	sw (sp+48),r8
     c90:	5b 89 00 60 	sw (sp+96),r9
     c94:	34 01 00 02 	mvi r1,2
     c98:	2a 42 00 00 	lw r2,(r18+0)
     c9c:	2a 23 00 00 	lw r3,(r17+0)
     ca0:	2a 04 00 00 	lw r4,(r16+0)
     ca4:	5b 81 00 64 	sw (sp+100),r1
     ca8:	e3 ff ff d4 	bi bf8 <main+0x264>

00000cac <isr_null>:
/***************************************************************************
 * IRQ handling
 */
void isr_null()
{
}
     cac:	c3 a0 00 00 	ret

00000cb0 <tic_isr>:

uint32_t tic_msec;

void tic_isr()
{
	tic_msec++;
     cb0:	78 01 00 00 	mvhi r1,0x0
     cb4:	38 21 12 f0 	ori r1,r1,0x12f0
     cb8:	28 23 00 00 	lw r3,(r1+0)
	timer0->tcr0     = TIMER_EN | TIMER_AR | TIMER_IRQEN;
     cbc:	78 02 00 00 	mvhi r2,0x0
     cc0:	38 42 12 50 	ori r2,r2,0x1250
     cc4:	28 42 00 00 	lw r2,(r2+0)

uint32_t tic_msec;

void tic_isr()
{
	tic_msec++;
     cc8:	34 63 00 01 	addi r3,r3,1
     ccc:	58 23 00 00 	sw (r1+0),r3
	timer0->tcr0     = TIMER_EN | TIMER_AR | TIMER_IRQEN;
     cd0:	34 01 00 0e 	mvi r1,14
     cd4:	58 41 00 00 	sw (r2+0),r1
}
     cd8:	c3 a0 00 00 	ret

00000cdc <irq_handler>:
void isr_null()
{
}

void irq_handler(uint32_t pending)
{
     cdc:	37 9c ff f0 	addi sp,sp,-16
     ce0:	5b 8b 00 10 	sw (sp+16),r11
     ce4:	5b 8c 00 0c 	sw (sp+12),r12
     ce8:	5b 8d 00 08 	sw (sp+8),r13
     cec:	5b 9d 00 04 	sw (sp+4),ra
     cf0:	78 0b 00 00 	mvhi r11,0x0
     cf4:	39 6b 12 70 	ori r11,r11,0x1270
     cf8:	b8 20 60 00 	mv r12,r1
 */
void isr_null()
{
}

void irq_handler(uint32_t pending)
     cfc:	35 6d 00 80 	addi r13,r11,128
     d00:	e0 00 00 04 	bi d10 <irq_handler+0x34>
{
	int i;

	for(i=0; i<32; i++) {
		if (pending & 0x01) (*isr_table[i])();
     d04:	35 6b 00 04 	addi r11,r11,4

void irq_handler(uint32_t pending)
{
	int i;

	for(i=0; i<32; i++) {
     d08:	45 6d 00 08 	be r11,r13,d28 <irq_handler+0x4c>
		if (pending & 0x01) (*isr_table[i])();
		pending >>= 1;
     d0c:	01 8c 00 01 	srui r12,r12,1
void irq_handler(uint32_t pending)
{
	int i;

	for(i=0; i<32; i++) {
		if (pending & 0x01) (*isr_table[i])();
     d10:	21 81 00 01 	andi r1,r12,0x1
     d14:	44 20 ff fc 	be r1,r0,d04 <irq_handler+0x28>
     d18:	29 61 00 00 	lw r1,(r11+0)
     d1c:	35 6b 00 04 	addi r11,r11,4
     d20:	d8 20 00 00 	call r1

void irq_handler(uint32_t pending)
{
	int i;

	for(i=0; i<32; i++) {
     d24:	5d 6d ff fa 	bne r11,r13,d0c <irq_handler+0x30>
		if (pending & 0x01) (*isr_table[i])();
		pending >>= 1;
	}
}
     d28:	2b 9d 00 04 	lw ra,(sp+4)
     d2c:	2b 8b 00 10 	lw r11,(sp+16)
     d30:	2b 8c 00 0c 	lw r12,(sp+12)
     d34:	2b 8d 00 08 	lw r13,(sp+8)
     d38:	37 9c 00 10 	addi sp,sp,16
     d3c:	c3 a0 00 00 	ret

00000d40 <isr_init>:

void isr_init()
{
     d40:	78 01 00 00 	mvhi r1,0x0
     d44:	78 02 00 00 	mvhi r2,0x0
     d48:	38 21 12 70 	ori r1,r1,0x1270
     d4c:	38 42 0c ac 	ori r2,r2,0xcac
		if (pending & 0x01) (*isr_table[i])();
		pending >>= 1;
	}
}

void isr_init()
     d50:	34 23 00 80 	addi r3,r1,128
{
	int i;
	for(i=0; i<32; i++)
		isr_table[i] = &isr_null;
     d54:	58 22 00 00 	sw (r1+0),r2
     d58:	34 21 00 04 	addi r1,r1,4
}

void isr_init()
{
	int i;
	for(i=0; i<32; i++)
     d5c:	5c 23 ff fe 	bne r1,r3,d54 <isr_init+0x14>
		isr_table[i] = &isr_null;
}
     d60:	c3 a0 00 00 	ret

00000d64 <isr_register>:

void isr_register(int irq, isr_ptr_t isr)
{
	isr_table[irq] = isr;
     d64:	78 03 00 00 	mvhi r3,0x0
     d68:	3c 21 00 02 	sli r1,r1,2
     d6c:	38 63 12 70 	ori r3,r3,0x1270
     d70:	b4 61 18 00 	add r3,r3,r1
     d74:	58 62 00 00 	sw (r3+0),r2
}
     d78:	c3 a0 00 00 	ret

00000d7c <isr_unregister>:

void isr_unregister(int irq)
{
	isr_table[irq] = &isr_null;
     d7c:	78 03 00 00 	mvhi r3,0x0
     d80:	3c 21 00 02 	sli r1,r1,2
     d84:	38 63 12 70 	ori r3,r3,0x1270
     d88:	78 02 00 00 	mvhi r2,0x0
     d8c:	b4 61 18 00 	add r3,r3,r1
     d90:	38 42 0c ac 	ori r2,r2,0xcac
     d94:	58 62 00 00 	sw (r3+0),r2
}
     d98:	c3 a0 00 00 	ret

00000d9c <msleep>:
void msleep(uint32_t msec)
{
	uint32_t tcr;

	// Use timer0.1
	timer0->compare1 = (FCPU/1000)*msec;
     d9c:	78 02 00 00 	mvhi r2,0x0
     da0:	38 42 12 50 	ori r2,r2,0x1250
     da4:	38 03 c3 50 	mvu r3,0xc350
     da8:	28 42 00 00 	lw r2,(r2+0)
     dac:	88 23 08 00 	mul r1,r1,r3
     db0:	58 41 00 10 	sw (r2+16),r1
	timer0->counter1 = 0;
     db4:	58 40 00 14 	sw (r2+20),r0
	timer0->tcr1 = TIMER_EN;
     db8:	34 01 00 08 	mvi r1,8
     dbc:	58 41 00 0c 	sw (r2+12),r1

	do {
		//halt();
 		tcr = timer0->tcr1;
     dc0:	28 41 00 0c 	lw r1,(r2+12)
 	} while ( ! (tcr & TIMER_TRIG) );
     dc4:	20 21 00 01 	andi r1,r1,0x1
     dc8:	44 20 ff fe 	be r1,r0,dc0 <msleep+0x24>
}
     dcc:	c3 a0 00 00 	ret

00000dd0 <nsleep>:
void nsleep(uint32_t nsec)
{
	uint32_t tcr;

	// Use timer0.1
	timer0->compare1 = (FCPU/1000000)*nsec;
     dd0:	78 02 00 00 	mvhi r2,0x0
     dd4:	38 42 12 50 	ori r2,r2,0x1250
     dd8:	28 42 00 00 	lw r2,(r2+0)
     ddc:	08 21 00 32 	muli r1,r1,50
     de0:	58 41 00 10 	sw (r2+16),r1
	timer0->counter1 = 0;
     de4:	58 40 00 14 	sw (r2+20),r0
	timer0->tcr1 = TIMER_EN;
     de8:	34 01 00 08 	mvi r1,8
     dec:	58 41 00 0c 	sw (r2+12),r1

	do {
		//halt();
 		tcr = timer0->tcr1;
     df0:	28 41 00 0c 	lw r1,(r2+12)
 	} while ( ! (tcr & TIMER_TRIG) );
     df4:	20 21 00 01 	andi r1,r1,0x1
     df8:	44 20 ff fe 	be r1,r0,df0 <nsleep+0x20>
}
     dfc:	c3 a0 00 00 	ret

00000e00 <tic_init>:
void tic_init()
{
	tic_msec = 0;

	// Setup timer0.0
	timer0->compare0 = (FCPU/10000);
     e00:	78 01 00 00 	mvhi r1,0x0
     e04:	38 21 12 50 	ori r1,r1,0x1250
     e08:	28 23 00 00 	lw r3,(r1+0)
     e0c:	34 02 13 88 	mvi r2,5000
	timer0->tcr0     = TIMER_EN | TIMER_AR | TIMER_IRQEN;
}

void tic_init()
{
	tic_msec = 0;
     e10:	78 01 00 00 	mvhi r1,0x0

	// Setup timer0.0
	timer0->compare0 = (FCPU/10000);
     e14:	58 62 00 04 	sw (r3+4),r2
	timer0->tcr0     = TIMER_EN | TIMER_AR | TIMER_IRQEN;
}

void tic_init()
{
	tic_msec = 0;
     e18:	38 21 12 f0 	ori r1,r1,0x12f0

	// Setup timer0.0
	timer0->compare0 = (FCPU/10000);
	timer0->counter0 = 0;
     e1c:	58 60 00 08 	sw (r3+8),r0
	timer0->tcr0     = TIMER_EN | TIMER_AR | TIMER_IRQEN;
}

void tic_init()
{
	tic_msec = 0;
     e20:	58 20 00 00 	sw (r1+0),r0
		isr_table[i] = &isr_null;
}

void isr_register(int irq, isr_ptr_t isr)
{
	isr_table[irq] = isr;
     e24:	78 02 00 00 	mvhi r2,0x0
     e28:	78 01 00 00 	mvhi r1,0x0
	tic_msec = 0;

	// Setup timer0.0
	timer0->compare0 = (FCPU/10000);
	timer0->counter0 = 0;
	timer0->tcr0     = TIMER_EN | TIMER_AR | TIMER_IRQEN;
     e2c:	34 04 00 0e 	mvi r4,14
     e30:	58 64 00 00 	sw (r3+0),r4
		isr_table[i] = &isr_null;
}

void isr_register(int irq, isr_ptr_t isr)
{
	isr_table[irq] = isr;
     e34:	38 21 12 70 	ori r1,r1,0x1270
     e38:	38 42 0c b0 	ori r2,r2,0xcb0
     e3c:	58 22 00 04 	sw (r1+4),r2
	timer0->compare0 = (FCPU/10000);
	timer0->counter0 = 0;
	timer0->tcr0     = TIMER_EN | TIMER_AR | TIMER_IRQEN;

	isr_register(1, &tic_isr);
}
     e40:	c3 a0 00 00 	ret

00000e44 <uart_init>:
	//uart0->lcr = 0x03;  // Line Control Register:    8N1
	//uart0->mcr = 0x00;  // Modem Control Register

	// Setup Divisor register (Fclk / Baud)
	//uart0->div = (FCPU/(57600*16));
}
     e44:	c3 a0 00 00 	ret

00000e48 <uart_getchar>:

char uart_getchar()
{   
     e48:	78 01 00 00 	mvhi r1,0x0
     e4c:	38 21 12 4c 	ori r1,r1,0x124c
     e50:	28 22 00 00 	lw r2,(r1+0)
	while (! (uart0->ucr & UART_DR)) ; //Se queda esperando a que haya un 1 en rx_avail.
     e54:	28 41 00 00 	lw r1,(r2+0)
     e58:	20 21 00 01 	andi r1,r1,0x1
     e5c:	44 20 ff fe 	be r1,r0,e54 <uart_getchar+0xc>
	return uart0->rxtx;
     e60:	28 41 00 04 	lw r1,(r2+4)
}
     e64:	20 21 00 ff 	andi r1,r1,0xff
     e68:	c3 a0 00 00 	ret

00000e6c <uart_putchar>:

void uart_putchar(char c)
{
     e6c:	78 02 00 00 	mvhi r2,0x0
     e70:	38 42 12 4c 	ori r2,r2,0x124c
     e74:	28 43 00 00 	lw r3,(r2+0)
     e78:	20 21 00 ff 	andi r1,r1,0xff
	while (uart0->ucr & UART_BUSY); //si ucr muestra un 1 (ART_BUSY), entonces queda en el while siempre. Sale cuando no está ocupado
     e7c:	28 62 00 00 	lw r2,(r3+0)
     e80:	20 42 00 10 	andi r2,r2,0x10
     e84:	5c 40 ff fe 	bne r2,r0,e7c <uart_putchar+0x10>
	uart0->rxtx = c; //COMO carajos envia c al wb_data_i. O mejor dicho, rxtx que es como tal.
     e88:	58 61 00 04 	sw (r3+4),r1
}
     e8c:	c3 a0 00 00 	ret

00000e90 <uart_putstr>:

void uart_putstr(char *str)
{
	char *c = str;
	while(*c) {
     e90:	40 24 00 00 	lbu r4,(r1+0)
     e94:	44 80 00 0b 	be r4,r0,ec0 <uart_putstr+0x30>
     e98:	78 02 00 00 	mvhi r2,0x0
     e9c:	38 42 12 4c 	ori r2,r2,0x124c
     ea0:	28 43 00 00 	lw r3,(r2+0)
	return uart0->rxtx;
}

void uart_putchar(char c)
{
	while (uart0->ucr & UART_BUSY); //si ucr muestra un 1 (ART_BUSY), entonces queda en el while siempre. Sale cuando no está ocupado
     ea4:	28 62 00 00 	lw r2,(r3+0)
     ea8:	20 42 00 10 	andi r2,r2,0x10
     eac:	5c 40 ff fe 	bne r2,r0,ea4 <uart_putstr+0x14>
	uart0->rxtx = c; //COMO carajos envia c al wb_data_i. O mejor dicho, rxtx que es como tal.
     eb0:	58 64 00 04 	sw (r3+4),r4
void uart_putstr(char *str)
{
	char *c = str;
	while(*c) {
		uart_putchar(*c);
		c++;
     eb4:	34 21 00 01 	addi r1,r1,1
}

void uart_putstr(char *str)
{
	char *c = str;
	while(*c) {
     eb8:	40 24 00 00 	lbu r4,(r1+0)
     ebc:	5c 82 ff fa 	bne r4,r2,ea4 <uart_putstr+0x14>
     ec0:	c3 a0 00 00 	ret

00000ec4 <writeReg>:

*/
void writeReg(int addressReg, int data_Wr)
{
	addressReg = addressReg & 0x7E;//0111 1110
	SPI0->address = addressReg;
     ec4:	78 03 00 00 	mvhi r3,0x0
     ec8:	38 63 12 58 	ori r3,r3,0x1258
     ecc:	28 63 00 00 	lw r3,(r3+0)
[0] = siempre es cero

*/
void writeReg(int addressReg, int data_Wr)
{
	addressReg = addressReg & 0x7E;//0111 1110
     ed0:	20 21 00 7e 	andi r1,r1,0x7e
	SPI0->address = addressReg;
     ed4:	58 61 00 04 	sw (r3+4),r1
	SPI0->dataWr = data_Wr;
     ed8:	58 62 00 08 	sw (r3+8),r2
	while(SPI0->status & 0x01);
     edc:	28 61 00 0c 	lw r1,(r3+12)
     ee0:	20 21 00 01 	andi r1,r1,0x1
     ee4:	5c 20 ff fe 	bne r1,r0,edc <writeReg+0x18>
}
     ee8:	c3 a0 00 00 	ret

00000eec <readReg>:

int readReg(int addressReg)
{
	addressReg = (addressReg & 0x7E) | 0x80;//(0111 1110 & address) | 1000 0000
	SPI0->address = addressReg;
     eec:	78 02 00 00 	mvhi r2,0x0
     ef0:	38 42 12 58 	ori r2,r2,0x1258
     ef4:	28 42 00 00 	lw r2,(r2+0)
	while(SPI0->status & 0x01);
}

int readReg(int addressReg)
{
	addressReg = (addressReg & 0x7E) | 0x80;//(0111 1110 & address) | 1000 0000
     ef8:	20 21 00 7e 	andi r1,r1,0x7e
     efc:	38 21 00 80 	ori r1,r1,0x80
	SPI0->address = addressReg;
     f00:	58 41 00 04 	sw (r2+4),r1
	while(SPI0->status & 0x01);
     f04:	28 41 00 0c 	lw r1,(r2+12)
     f08:	20 21 00 01 	andi r1,r1,0x1
     f0c:	5c 20 ff fe 	bne r1,r0,f04 <readReg+0x18>
	return SPI0->dataRd;
     f10:	28 41 00 00 	lw r1,(r2+0)
}
     f14:	c3 a0 00 00 	ret

00000f18 <chooseRFID>:

void chooseRFID(int numberRFID)
{
	SPI0->chipSelect = numberRFID;
     f18:	78 02 00 00 	mvhi r2,0x0
     f1c:	38 42 12 58 	ori r2,r2,0x1258
     f20:	28 42 00 00 	lw r2,(r2+0)
     f24:	58 41 00 10 	sw (r2+16),r1
}
     f28:	c3 a0 00 00 	ret

00000f2c <writelcd>:

////FUNCIONES LCD

void writelcd(int numeroInstrucciones, int reg0, int reg1, int reg2, int reg3, int reg4, int reg5, int reg6, int reg7, int reg8, int reg9, int reg10, int reg11, int reg12, int reg13, int reg14, int reg15, int reg16, int reg17, int reg18, int reg19, int reg20, int reg21, int reg22, int reg23, int reg24, int reg25, int reg26, int reg27, int reg28, int reg29, int reg30, int reg31, int reg32, int reg33, int reg34, int reg35, int reg36, int reg37, int reg38, int reg39)
{     
      LCD0->numeroInstrucciones=numeroInstrucciones;
     f2c:	78 09 00 00 	mvhi r9,0x0
     f30:	39 29 12 5c 	ori r9,r9,0x125c
     f34:	29 29 00 00 	lw r9,(r9+0)
     f38:	20 21 ff ff 	andi r1,r1,0xffff
      LCD0->instruccion0=reg0;
     f3c:	20 42 ff ff 	andi r2,r2,0xffff

////FUNCIONES LCD

void writelcd(int numeroInstrucciones, int reg0, int reg1, int reg2, int reg3, int reg4, int reg5, int reg6, int reg7, int reg8, int reg9, int reg10, int reg11, int reg12, int reg13, int reg14, int reg15, int reg16, int reg17, int reg18, int reg19, int reg20, int reg21, int reg22, int reg23, int reg24, int reg25, int reg26, int reg27, int reg28, int reg29, int reg30, int reg31, int reg32, int reg33, int reg34, int reg35, int reg36, int reg37, int reg38, int reg39)
{     
      LCD0->numeroInstrucciones=numeroInstrucciones;
     f40:	0d 21 00 02 	sh (r9+2),r1
      LCD0->instruccion0=reg0;
     f44:	0d 22 00 04 	sh (r9+4),r2
      LCD0->instruccion1=reg1;
     f48:	20 63 ff ff 	andi r3,r3,0xffff
     f4c:	0d 23 00 06 	sh (r9+6),r3
      LCD0->instruccion2=reg2;
     f50:	20 84 ff ff 	andi r4,r4,0xffff
     f54:	0d 24 00 08 	sh (r9+8),r4
      LCD0->instruccion3=reg3;
     f58:	20 a5 ff ff 	andi r5,r5,0xffff
     f5c:	0d 25 00 0a 	sh (r9+10),r5
      LCD0->instruccion4=reg4;
     f60:	20 c6 ff ff 	andi r6,r6,0xffff
     f64:	0d 26 00 0c 	sh (r9+12),r6
      LCD0->instruccion5=reg5;
      LCD0->instruccion6=reg6;
      LCD0->instruccion7=reg7;
     f68:	2f 81 00 06 	lhu r1,(sp+6)
      LCD0->instruccion0=reg0;
      LCD0->instruccion1=reg1;
      LCD0->instruccion2=reg2;
      LCD0->instruccion3=reg3;
      LCD0->instruccion4=reg4;
      LCD0->instruccion5=reg5;
     f6c:	20 e7 ff ff 	andi r7,r7,0xffff
     f70:	0d 27 00 0e 	sh (r9+14),r7
      LCD0->instruccion6=reg6;
      LCD0->instruccion7=reg7;
      LCD0->instruccion8=reg8;
     f74:	2f 83 00 0a 	lhu r3,(sp+10)
      LCD0->instruccion1=reg1;
      LCD0->instruccion2=reg2;
      LCD0->instruccion3=reg3;
      LCD0->instruccion4=reg4;
      LCD0->instruccion5=reg5;
      LCD0->instruccion6=reg6;
     f78:	21 08 ff ff 	andi r8,r8,0xffff
     f7c:	0d 28 00 10 	sh (r9+16),r8
      LCD0->instruccion7=reg7;
      LCD0->instruccion8=reg8;
      LCD0->instruccion9=reg9;
     f80:	2f 82 00 0e 	lhu r2,(sp+14)
      LCD0->instruccion2=reg2;
      LCD0->instruccion3=reg3;
      LCD0->instruccion4=reg4;
      LCD0->instruccion5=reg5;
      LCD0->instruccion6=reg6;
      LCD0->instruccion7=reg7;
     f84:	0d 21 00 12 	sh (r9+18),r1
      LCD0->instruccion8=reg8;
      LCD0->instruccion9=reg9;
      LCD0->instruccion10=reg10;
     f88:	2f 81 00 12 	lhu r1,(sp+18)
      LCD0->instruccion3=reg3;
      LCD0->instruccion4=reg4;
      LCD0->instruccion5=reg5;
      LCD0->instruccion6=reg6;
      LCD0->instruccion7=reg7;
      LCD0->instruccion8=reg8;
     f8c:	0d 23 00 14 	sh (r9+20),r3
      LCD0->instruccion9=reg9;
      LCD0->instruccion10=reg10;
      LCD0->instruccion11=reg11;
     f90:	2f 83 00 16 	lhu r3,(sp+22)
      LCD0->instruccion4=reg4;
      LCD0->instruccion5=reg5;
      LCD0->instruccion6=reg6;
      LCD0->instruccion7=reg7;
      LCD0->instruccion8=reg8;
      LCD0->instruccion9=reg9;
     f94:	0d 22 00 16 	sh (r9+22),r2
      LCD0->instruccion10=reg10;
      LCD0->instruccion11=reg11;
      LCD0->instruccion12=reg12;
     f98:	2f 82 00 1a 	lhu r2,(sp+26)
      LCD0->instruccion5=reg5;
      LCD0->instruccion6=reg6;
      LCD0->instruccion7=reg7;
      LCD0->instruccion8=reg8;
      LCD0->instruccion9=reg9;
      LCD0->instruccion10=reg10;
     f9c:	0d 21 00 18 	sh (r9+24),r1
      LCD0->instruccion11=reg11;
      LCD0->instruccion12=reg12;
      LCD0->instruccion13=reg13;
     fa0:	2f 81 00 1e 	lhu r1,(sp+30)
      LCD0->instruccion6=reg6;
      LCD0->instruccion7=reg7;
      LCD0->instruccion8=reg8;
      LCD0->instruccion9=reg9;
      LCD0->instruccion10=reg10;
      LCD0->instruccion11=reg11;
     fa4:	0d 23 00 1a 	sh (r9+26),r3
      LCD0->instruccion12=reg12;
      LCD0->instruccion13=reg13;
      LCD0->instruccion14=reg14;
     fa8:	2f 83 00 22 	lhu r3,(sp+34)
      LCD0->instruccion7=reg7;
      LCD0->instruccion8=reg8;
      LCD0->instruccion9=reg9;
      LCD0->instruccion10=reg10;
      LCD0->instruccion11=reg11;
      LCD0->instruccion12=reg12;
     fac:	0d 22 00 1c 	sh (r9+28),r2
      LCD0->instruccion13=reg13;
      LCD0->instruccion14=reg14;
      LCD0->instruccion15=reg15;
     fb0:	2f 82 00 26 	lhu r2,(sp+38)
      LCD0->instruccion8=reg8;
      LCD0->instruccion9=reg9;
      LCD0->instruccion10=reg10;
      LCD0->instruccion11=reg11;
      LCD0->instruccion12=reg12;
      LCD0->instruccion13=reg13;
     fb4:	0d 21 00 1e 	sh (r9+30),r1
      LCD0->instruccion14=reg14;
      LCD0->instruccion15=reg15;
      LCD0->instruccion16=reg16;
     fb8:	2f 81 00 2a 	lhu r1,(sp+42)
      LCD0->instruccion9=reg9;
      LCD0->instruccion10=reg10;
      LCD0->instruccion11=reg11;
      LCD0->instruccion12=reg12;
      LCD0->instruccion13=reg13;
      LCD0->instruccion14=reg14;
     fbc:	0d 23 00 20 	sh (r9+32),r3
      LCD0->instruccion15=reg15;
      LCD0->instruccion16=reg16;
      LCD0->instruccion17=reg17;
     fc0:	2f 83 00 2e 	lhu r3,(sp+46)
      LCD0->instruccion10=reg10;
      LCD0->instruccion11=reg11;
      LCD0->instruccion12=reg12;
      LCD0->instruccion13=reg13;
      LCD0->instruccion14=reg14;
      LCD0->instruccion15=reg15;
     fc4:	0d 22 00 22 	sh (r9+34),r2
      LCD0->instruccion16=reg16;
      LCD0->instruccion17=reg17;
      LCD0->instruccion18=reg18;
     fc8:	2f 82 00 32 	lhu r2,(sp+50)
      LCD0->instruccion11=reg11;
      LCD0->instruccion12=reg12;
      LCD0->instruccion13=reg13;
      LCD0->instruccion14=reg14;
      LCD0->instruccion15=reg15;
      LCD0->instruccion16=reg16;
     fcc:	0d 21 00 24 	sh (r9+36),r1
      LCD0->instruccion17=reg17;
      LCD0->instruccion18=reg18;
      LCD0->instruccion19=reg19;
     fd0:	2f 81 00 36 	lhu r1,(sp+54)
      LCD0->instruccion12=reg12;
      LCD0->instruccion13=reg13;
      LCD0->instruccion14=reg14;
      LCD0->instruccion15=reg15;
      LCD0->instruccion16=reg16;
      LCD0->instruccion17=reg17;
     fd4:	0d 23 00 26 	sh (r9+38),r3
      LCD0->instruccion18=reg18;
     fd8:	0d 22 00 28 	sh (r9+40),r2
      LCD0->instruccion19=reg19;
      LCD0->instruccion20=reg20;
     fdc:	2f 82 00 3a 	lhu r2,(sp+58)
      LCD0->instruccion14=reg14;
      LCD0->instruccion15=reg15;
      LCD0->instruccion16=reg16;
      LCD0->instruccion17=reg17;
      LCD0->instruccion18=reg18;
      LCD0->instruccion19=reg19;
     fe0:	0d 21 00 2a 	sh (r9+42),r1
      LCD0->instruccion20=reg20;
      LCD0->instruccion21=reg21;
     fe4:	2f 81 00 3e 	lhu r1,(sp+62)
      LCD0->instruccion22=reg22;
     fe8:	2f 83 00 42 	lhu r3,(sp+66)
      LCD0->instruccion15=reg15;
      LCD0->instruccion16=reg16;
      LCD0->instruccion17=reg17;
      LCD0->instruccion18=reg18;
      LCD0->instruccion19=reg19;
      LCD0->instruccion20=reg20;
     fec:	0d 22 00 2c 	sh (r9+44),r2
      LCD0->instruccion21=reg21;
      LCD0->instruccion22=reg22;
      LCD0->instruccion23=reg23;
     ff0:	2f 82 00 46 	lhu r2,(sp+70)
      LCD0->instruccion16=reg16;
      LCD0->instruccion17=reg17;
      LCD0->instruccion18=reg18;
      LCD0->instruccion19=reg19;
      LCD0->instruccion20=reg20;
      LCD0->instruccion21=reg21;
     ff4:	0d 21 00 2e 	sh (r9+46),r1
      LCD0->instruccion22=reg22;
      LCD0->instruccion23=reg23;
      LCD0->instruccion24=reg24;
     ff8:	2f 81 00 4a 	lhu r1,(sp+74)
      LCD0->instruccion17=reg17;
      LCD0->instruccion18=reg18;
      LCD0->instruccion19=reg19;
      LCD0->instruccion20=reg20;
      LCD0->instruccion21=reg21;
      LCD0->instruccion22=reg22;
     ffc:	0d 23 00 30 	sh (r9+48),r3
      LCD0->instruccion23=reg23;
      LCD0->instruccion24=reg24;
      LCD0->instruccion25=reg25;
    1000:	2f 83 00 4e 	lhu r3,(sp+78)
      LCD0->instruccion18=reg18;
      LCD0->instruccion19=reg19;
      LCD0->instruccion20=reg20;
      LCD0->instruccion21=reg21;
      LCD0->instruccion22=reg22;
      LCD0->instruccion23=reg23;
    1004:	0d 22 00 32 	sh (r9+50),r2
      LCD0->instruccion24=reg24;
      LCD0->instruccion25=reg25;
      LCD0->instruccion26=reg26;
    1008:	2f 82 00 52 	lhu r2,(sp+82)
      LCD0->instruccion19=reg19;
      LCD0->instruccion20=reg20;
      LCD0->instruccion21=reg21;
      LCD0->instruccion22=reg22;
      LCD0->instruccion23=reg23;
      LCD0->instruccion24=reg24;
    100c:	0d 21 00 34 	sh (r9+52),r1
      LCD0->instruccion25=reg25;
      LCD0->instruccion26=reg26;
      LCD0->instruccion27=reg27;
    1010:	2f 81 00 56 	lhu r1,(sp+86)
      LCD0->instruccion20=reg20;
      LCD0->instruccion21=reg21;
      LCD0->instruccion22=reg22;
      LCD0->instruccion23=reg23;
      LCD0->instruccion24=reg24;
      LCD0->instruccion25=reg25;
    1014:	0d 23 00 36 	sh (r9+54),r3
      LCD0->instruccion26=reg26;
      LCD0->instruccion27=reg27;
      LCD0->instruccion28=reg28;
    1018:	2f 83 00 5a 	lhu r3,(sp+90)
      LCD0->instruccion21=reg21;
      LCD0->instruccion22=reg22;
      LCD0->instruccion23=reg23;
      LCD0->instruccion24=reg24;
      LCD0->instruccion25=reg25;
      LCD0->instruccion26=reg26;
    101c:	0d 22 00 38 	sh (r9+56),r2
      LCD0->instruccion27=reg27;
      LCD0->instruccion28=reg28;
      LCD0->instruccion29=reg29;
    1020:	2f 82 00 5e 	lhu r2,(sp+94)
      LCD0->instruccion22=reg22;
      LCD0->instruccion23=reg23;
      LCD0->instruccion24=reg24;
      LCD0->instruccion25=reg25;
      LCD0->instruccion26=reg26;
      LCD0->instruccion27=reg27;
    1024:	0d 21 00 3a 	sh (r9+58),r1
      LCD0->instruccion28=reg28;
      LCD0->instruccion29=reg29;
      LCD0->instruccion30=reg30;
    1028:	2f 81 00 62 	lhu r1,(sp+98)
      LCD0->instruccion23=reg23;
      LCD0->instruccion24=reg24;
      LCD0->instruccion25=reg25;
      LCD0->instruccion26=reg26;
      LCD0->instruccion27=reg27;
      LCD0->instruccion28=reg28;
    102c:	0d 23 00 3c 	sh (r9+60),r3
      LCD0->instruccion29=reg29;
      LCD0->instruccion30=reg30;
      LCD0->instruccion31=reg31;
    1030:	2f 83 00 66 	lhu r3,(sp+102)
      LCD0->instruccion24=reg24;
      LCD0->instruccion25=reg25;
      LCD0->instruccion26=reg26;
      LCD0->instruccion27=reg27;
      LCD0->instruccion28=reg28;
      LCD0->instruccion29=reg29;
    1034:	0d 22 00 3e 	sh (r9+62),r2
      LCD0->instruccion30=reg30;
      LCD0->instruccion31=reg31;
      LCD0->instruccion32=reg32;
    1038:	2f 82 00 6a 	lhu r2,(sp+106)
      LCD0->instruccion25=reg25;
      LCD0->instruccion26=reg26;
      LCD0->instruccion27=reg27;
      LCD0->instruccion28=reg28;
      LCD0->instruccion29=reg29;
      LCD0->instruccion30=reg30;
    103c:	0d 21 00 40 	sh (r9+64),r1
      LCD0->instruccion31=reg31;
      LCD0->instruccion32=reg32;
      LCD0->instruccion33=reg33;
    1040:	2f 81 00 6e 	lhu r1,(sp+110)
      LCD0->instruccion26=reg26;
      LCD0->instruccion27=reg27;
      LCD0->instruccion28=reg28;
      LCD0->instruccion29=reg29;
      LCD0->instruccion30=reg30;
      LCD0->instruccion31=reg31;
    1044:	0d 23 00 42 	sh (r9+66),r3
      LCD0->instruccion32=reg32;
      LCD0->instruccion33=reg33;
      LCD0->instruccion34=reg34;
    1048:	2f 83 00 72 	lhu r3,(sp+114)
      LCD0->instruccion27=reg27;
      LCD0->instruccion28=reg28;
      LCD0->instruccion29=reg29;
      LCD0->instruccion30=reg30;
      LCD0->instruccion31=reg31;
      LCD0->instruccion32=reg32;
    104c:	0d 22 00 44 	sh (r9+68),r2
      LCD0->instruccion33=reg33;
      LCD0->instruccion34=reg34;
      LCD0->instruccion35=reg35;
    1050:	2f 82 00 76 	lhu r2,(sp+118)
      LCD0->instruccion28=reg28;
      LCD0->instruccion29=reg29;
      LCD0->instruccion30=reg30;
      LCD0->instruccion31=reg31;
      LCD0->instruccion32=reg32;
      LCD0->instruccion33=reg33;
    1054:	0d 21 00 46 	sh (r9+70),r1
      LCD0->instruccion34=reg34;
    1058:	0d 23 00 48 	sh (r9+72),r3
      LCD0->instruccion35=reg35;
      LCD0->instruccion36=reg36;
    105c:	2f 81 00 7a 	lhu r1,(sp+122)
      LCD0->instruccion30=reg30;
      LCD0->instruccion31=reg31;
      LCD0->instruccion32=reg32;
      LCD0->instruccion33=reg33;
      LCD0->instruccion34=reg34;
      LCD0->instruccion35=reg35;
    1060:	0d 22 00 4a 	sh (r9+74),r2
      LCD0->instruccion36=reg36;
      LCD0->instruccion37=reg37;
    1064:	2f 83 00 7e 	lhu r3,(sp+126)
      LCD0->instruccion38=reg38;
    1068:	2f 82 00 82 	lhu r2,(sp+130)
      LCD0->instruccion31=reg31;
      LCD0->instruccion32=reg32;
      LCD0->instruccion33=reg33;
      LCD0->instruccion34=reg34;
      LCD0->instruccion35=reg35;
      LCD0->instruccion36=reg36;
    106c:	0d 21 00 4c 	sh (r9+76),r1
      LCD0->instruccion37=reg37;
      LCD0->instruccion38=reg38;
      LCD0->instruccion39=reg39;
    1070:	2f 81 00 86 	lhu r1,(sp+134)
      LCD0->instruccion32=reg32;
      LCD0->instruccion33=reg33;
      LCD0->instruccion34=reg34;
      LCD0->instruccion35=reg35;
      LCD0->instruccion36=reg36;
      LCD0->instruccion37=reg37;
    1074:	0d 23 00 4e 	sh (r9+78),r3
      LCD0->instruccion38=reg38;
    1078:	0d 22 00 50 	sh (r9+80),r2
      LCD0->instruccion39=reg39;
    107c:	0d 21 00 52 	sh (r9+82),r1
      LCD0->init=1;
    1080:	34 01 00 01 	mvi r1,1
    1084:	0d 21 00 00 	sh (r9+0),r1
      LCD0->init=0;
    1088:	0d 20 00 00 	sh (r9+0),r0
      
}
    108c:	c3 a0 00 00 	ret

00001090 <Leerteclado>:

//Teclado functions

int Leerteclado()
{
	return Teclado0->teclaoprimida;	
    1090:	78 01 00 00 	mvhi r1,0x0
    1094:	38 21 12 60 	ori r1,r1,0x1260
    1098:	28 21 00 00 	lw r1,(r1+0)
    109c:	28 21 00 00 	lw r1,(r1+0)
}
    10a0:	c3 a0 00 00 	ret
